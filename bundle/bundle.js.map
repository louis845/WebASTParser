{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://WebASTParser/webpack/universalModuleDefinition","webpack://WebASTParser/webpack/bootstrap","webpack://WebASTParser/webpack/runtime/define property getters","webpack://WebASTParser/webpack/runtime/hasOwnProperty shorthand","webpack://WebASTParser/webpack/runtime/make namespace object","webpack://WebASTParser/./src/parsing/ParsingTypes.ts","webpack://WebASTParser/./src/utils.ts","webpack://WebASTParser/./src/visualizer/TokenVisualizer.ts","webpack://WebASTParser/./src/nodes/SyntaxNode.ts","webpack://WebASTParser/./src/nodes/Argument.ts","webpack://WebASTParser/./src/nodes/Attributes.ts","webpack://WebASTParser/./src/nodes/Classes.ts","webpack://WebASTParser/./src/nodes/Comments.ts","webpack://WebASTParser/./src/nodes/FunctionDeclaration.ts","webpack://WebASTParser/./src/nodes/FunctionGroups.ts","webpack://WebASTParser/./src/nodes/Functions.ts","webpack://WebASTParser/./src/nodes/References.ts","webpack://WebASTParser/./src/nodes/TopLevel.ts","webpack://WebASTParser/./src/CodeParserImplError.ts","webpack://WebASTParser/./src/parsing/ASTGenericTokenizer.ts","webpack://WebASTParser/./src/visualizer/TreeTokenVisualizer.ts","webpack://WebASTParser/./src/parsing/AbstractTokenizer.ts","webpack://WebASTParser/./src/impl/python/PythonTokenizer.ts","webpack://WebASTParser/./src/impl/typescript/TypeScriptTokenizer.ts","webpack://WebASTParser/./src/impl/python/PythonParser.ts","webpack://WebASTParser/./src/parsing/ASTFaithfulTokenizer.ts","webpack://WebASTParser/./src/matchers/StringExpressionMatcher.ts","webpack://WebASTParser/./src/CodeParsingError.ts","webpack://WebASTParser/./src/matchers/BracesMatcher.ts","webpack://WebASTParser/./src/parsing/AbstractSyntaxTree.ts","webpack://WebASTParser/./src/parsing/AbstractParser.ts","webpack://WebASTParser/./src/impl/python/PythonSimplificationTokenizer.ts","webpack://WebASTParser/./src/impl/typescript/TypeScriptSimplificationTokenizer.ts","webpack://WebASTParser/./src/visualizer/ASTFlatteningUtils.ts","webpack://WebASTParser/./src/impl/typescript/TypeScriptVarDeclMatcher.ts","webpack://WebASTParser/./src/impl/typescript/TypeScriptParser.ts","webpack://WebASTParser/./src/visualizer/InitTokenVisualizer.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebASTParser\"] = factory();\n\telse\n\t\troot[\"WebASTParser\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { CharacterRange } from \"../utils\";\nimport { SyntaxNode } from \"../nodes\";\n\nexport enum TokenType {\n    MULTILINE_COMMENTS_OR_STRINGS = \"MULTILINE_COMMENTS_OR_STRINGS\",\n    SINGLELINE_COMMENTS = \"SINGLELINE_COMMENTS\",\n    STRINGS = \"STRINGS\",\n    SPACINGS = \"SPACINGS\",\n    BRACES = \"BRACES\",\n    COMMAS = \"COMMAS\",\n    OTHERS = \"OTHERS\",\n    CONTINUATION = \"CONTINUATION\" // Dummy value, won't be passed to actual tokens.\n};\n\nexport type Token = {\n    stringContents: string;\n    tokenType: TokenType;\n    characterRange: CharacterRange\n};\n\nexport type TokenRange = {\n    startTok: number, endTok: number\n};\n\nexport type SymbolInfo = { symbolType: Terminal | NonTerminal; parseRange?: TokenRange; nodeCreationInformation?: Record<string, any> };\n\nexport type SymbolAdditionDirective = {\n    symbol: SymbolInfo,\n    secondSymbol?: SymbolInfo,\n    secondSymbolLen?: number,\n    firstTwoSymbolsEndBufferLen?: number\n};\n\nexport enum NonTerminal {\n    TOP_LEVEL = \"TOP_LEVEL\",\n    CLASSES = \"CLASSES\",\n    FUNCTIONS = \"FUNCTIONS\",\n    FUNCTION_DECLARATION = \"FUNCTION_DECLARATION\",\n    FUNCTION_BODY = \"FUNCTION_BODY\"\n}\n\nexport enum Terminal {\n    COMMENT_SINGLELINE = \"COMMENT_SINGLELINE\",\n    COMMENT_MULTILINE = \"COMMENT_MULTILINE\",\n    REFERENCES = \"REFERENCES\",\n    ARGUMENT = \"ARGUMENT\",\n    ATTRIBUTES = \"ATTRIBUTES\",\n    FILLER = \"FILLER\",\n    STATEMENTS_FILLER = \"STATEMENTS_FILLER\"\n}\n\nexport function isTerminal(symbol: string): boolean {\n    return Object.values(Terminal).includes(symbol as Terminal);\n}","export interface Range {\n    start_line: number;\n    start_character: number;\n    end_line: number;\n    end_character: number;\n}\n\nexport interface Index {\n    line: number;\n    character: number;\n}\n\nexport type CharacterRange = {\n    start: number, end: number\n}\n\n/**\n * Splits a code string into an array of lines, handling different newline characters.\n * @param codeString The source code as a single string.\n * @returns An array of strings, each representing a line of the source code.\n */\nexport function splitIntoLines(codeString: string): string[] {\n    // Handle both Windows (\\r\\n) and Unix (\\n) newline characters\n    return codeString.split(/\\r?\\n/);\n}\n\n/**\n * Converts a Range to start and end Index objects.\n * @param range The range to convert.\n * @returns An object containing start and end Index.\n */\nexport function rangeToIndexes(range: Range): { start: Index; end: Index } {\n    return {\n        start: { line: range.start_line, character: range.start_character },\n        end: { line: range.end_line, character: range.end_character },\n    };\n}\n\n/**\n * Extracts the start index from the range\n * @param range The range\n * @returns The start index\n */\nexport function rangeToStartIndex(range: Range): Index {\n    return { line: range.start_line, character: range.start_character };\n}\n\n/**\n * Extracts the end index from the range\n * @param range The range\n * @returns The end index\n */\nexport function rangeToEndIndex(range: Range): Index {\n    return { line: range.end_line, character: range.end_character };\n}\n\n/**\n * Converts start and end Index objects to a Range.\n * @param start The starting Index.\n * @param end The ending Index.\n * @returns The corresponding Range.\n */\nexport function indexesToRange(start: Index, end: Index): Range {\n    return {\n        start_line: start.line,\n        start_character: start.character,\n        end_line: end.line,\n        end_character: end.character,\n    };\n}\n\n/**\n * Retrieves the character at the specified Index.\n * @param codeLines The source code split into lines.\n * @param index The Index specifying the position.\n * @returns The character at the Index, or \"\\n\" if at the end of a line.\n */\nexport function getCharacter(codeLines: string[], index: Index): string {\n    const { line, character } = index;\n    if (line < 0 || line >= codeLines.length) {\n        throw new Error(`Invalid line number: ${line}`);\n    }\n    const lineContent = codeLines[line];\n    if (character < 0 || character > lineContent.length) {\n        throw new Error(`Invalid character position: ${character} in line ${line}`);\n    }\n    if (character === lineContent.length) {\n        return \"\\n\";\n    }\n    return lineContent.charAt(character);\n}\n\n/**\n * Retrieves the maximum range of the source code.\n * @param codeLines The source code split into lines.\n * @returns The maximum Range covering the entire source code.\n */\nexport function getMaxRange(codeLines: string[]): Range {\n    if (codeLines.length === 0) {\n        return {\n            start_line: 0,\n            start_character: 0,\n            end_line: 0,\n            end_character: 0,\n        };\n    }\n    return {\n        start_line: 0,\n        start_character: 0,\n        end_line: codeLines.length,\n        end_character: 0,\n    };\n}\n\n/**\n * Gets the next Index after the given Index. If the next index is (codeLines.length, 0), this is supported (dummy end index that if passed to getCharacter throws error).\n * @param codeLines The source code split into lines.\n * @param index The current Index.\n * @returns The next Index.\n */\nexport function next(codeLines: string[], index: Index): Index {\n    const { line, character } = index;\n    if (line >= codeLines.length) {\n        throw Error(\"The next index will be completely out of bounds!\");\n    }\n    if (line < 0) {\n        throw Error(\"Invalid line!\");\n    }\n\n    if (character < codeLines[line].length) {\n        return { line, character: character + 1 };\n    } else if (character === codeLines[line].length) {\n        return { line: line + 1, character: 0 };\n    } else {\n        throw new Error(`Invalid character position: ${character} in line ${line}`);\n    }\n}\n\n/**\n * Utility function to check if two ranges are adjacent.\n * @param range1 First range.\n * @param range2 Second range.\n * @returns True if range1 is immediately before range2, false otherwise.\n */\nexport function areRangesAdjacent(range1: Range, range2: Range): boolean {\n    return (\n        range1.end_line === range2.start_line &&\n        range1.end_character === range2.start_character\n    );\n}\n\n/**\n * Utility function to compare two indices.\n * @param index1 The first index\n * @param index2 The second index\n * @returns Returns -1,0,1, when index1 < index2, index1 == index2, index1 > index2 respectively\n */\nexport function compare(index1: Index, index2: Index): number {\n    if (index1.line < index2.line) {\n        return -1;\n    } else if (index2.line < index1.line) {\n        return 1;\n    } else {\n        if (index1.character < index2.character) {\n            return -1;\n        } else if (index2.character < index1.character) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}\n\n/**\n * Utility function to merge multiple ranges into a single range.\n * Assumes that the ranges are sorted and contiguous.\n * @param ranges Array of ranges to merge.\n * @returns A single merged range.\n */\nexport function mergeRanges(ranges: Range[]): Range {\n    if (ranges.length === 0) {\n        throw new Error(\"No ranges to merge.\");\n    }\n\n    let {start, end} : {start: Index, end: Index} = rangeToIndexes(ranges[0]);\n    for (let i = 1; i < ranges.length; i++) {\n        let {start: start2, end: end2} : {start: Index, end: Index} = rangeToIndexes(ranges[i]);\n        if (compare(start2, start) == -1) { // start2 < start\n            start = start2;\n        }\n        if (compare(end, end2) == -1) { // end < end2\n            end = end2;\n        }\n    }\n\n    return {\n        start_line: start.line,\n        start_character: start.character,\n        end_line: end.line,\n        end_character: end.character,\n    };\n}\n\n/**\n * Utility function to see if a range (not necessarily strictly) contains another range.\n * @param biggerRange The bigger range\n * @param insideRange The inside range\n * @returns Whether biggerRange (not necessarily strictly) contains insideRange.\n */\nexport function contains(biggerRange: Range, insideRange: Range) {\n    return (compare(rangeToIndexes(biggerRange).start, rangeToIndexes(insideRange).start) <= 0) && // biggerRange.start <= insideRange.start\n        (compare(rangeToIndexes(insideRange).end, rangeToIndexes(biggerRange).end) <= 0) // insideRange.end <= biggerRange.end\n}\n\n/**\n * Returns whether the range contains the index.\n * @param range Range\n * @param index Index\n * @returns Whether range contains index.\n */\nexport function containsIndex(range: Range, index: Index): boolean {\n    return (compare(rangeToIndexes(range).start, index) <= 0) // range.start <= index\n        && (compare(index, rangeToIndexes(range).end) < 0) // index < range.end\n}","import { Token, TokenType } from \"../parsing/ParsingTypes\";\n\nconst TOKEN_COLORS: { [key in TokenType]: string[] } = {\n    [TokenType.MULTILINE_COMMENTS_OR_STRINGS]: [\"#ffeb3b\", \"#efdb2b\"], // Yellow\n    [TokenType.SINGLELINE_COMMENTS]: [\"#c8e6c9\", \"#b8d6b9\"], // Light Green\n    [TokenType.STRINGS]: [\"#bbdefb\", \"#abceeb\"], // Light Blue\n    [TokenType.SPACINGS]: [\"#f0f0f0\", \"#e0e0e0\"], // Light Gray\n    [TokenType.BRACES]: [\"#ffcdd2\", \"#efbdc2\"], // Light Red\n    [TokenType.COMMAS]: [\"#e0ffff\", \"#d0efef\"], // Light Cyan\n    [TokenType.OTHERS]: [\"#d1c4e9\", \"#c1b4d9\"], // Light Purple\n    [TokenType.CONTINUATION]: [\"#ff0000\", \"#ff0000\"], // Red, since this is not expected\n};\n\nclass TokenVisualizer extends HTMLElement {\n    private tokens: Token[] = [];\n    private container: HTMLElement;\n\n    constructor(initialTokens: Token[] = []) {\n        super();\n        this.attachShadow({ mode: \"open\" });\n\n        // Create a container for the tokens\n        this.container = document.createElement(\"div\");\n        this.container.style.fontFamily = \"monospace\";\n        this.container.style.whiteSpace = \"pre-wrap\"; // Preserve whitespace and line breaks\n        this.container.style.padding = \"10px\";\n        this.container.style.border = \"1px solid #ccc\";\n        this.container.style.borderRadius = \"4px\";\n        this.shadowRoot!.appendChild(this.container);\n\n        // Initialize with initial tokens\n        if (initialTokens.length > 0) {\n            this.tokens = initialTokens;\n            this.render();\n        }\n    }\n\n    // Method to update tokens and re-render\n    public update(toks: Token[]) {\n        this.tokens = toks;\n        this.render();\n    }\n\n    // Render the tokens into the container\n    private render() {\n        // Clear existing content\n        this.container.innerHTML = \"\";\n\n        let count: number = 0;\n        this.tokens.forEach(token => {\n            const tokenType = token.tokenType;\n            const bgColor = TOKEN_COLORS[tokenType] || \"#ffffff\";\n            const borderColor = \"#00000033\"; // Very soft black border\n\n            // Split the stringContents by '\\n' to handle newlines\n            const parts = token.stringContents.split(\"\\n\");\n            parts.forEach((part, index) => {\n                const span = document.createElement(\"span\");\n                span.textContent = part;\n\n                span.style.backgroundColor = bgColor[count % 2];\n                span.style.border = `1px solid ${borderColor}`;\n                span.style.borderRadius = \"3px\";\n                span.style.padding = \"2px 4px\";\n                span.style.margin = \"1px\";\n                span.style.display = \"inline-block\";\n\n                if (index < parts.length - 1) {\n                    span.textContent = span.textContent + \"\\\\n\";\n                    this.container.appendChild(span);\n                    this.container.appendChild(document.createElement(\"br\"));\n                } else {\n                    if (span.textContent.length > 0) {\n                        this.container.appendChild(span);\n                    }\n                }\n            });\n            count++;\n        });\n    }\n}\n\n// Export the class if needed elsewhere\nexport { TokenVisualizer };","import { Range, mergeRanges, contains, indexesToRange, rangeToIndexes } from \"../utils\";\n\nexport abstract class SyntaxNode {\n    protected parent: SyntaxNode | null;\n    protected children: SyntaxNode[];\n    public extra_data: Record<string, any>;\n    private range: Range;\n    private innerRangeOverride: Range | null;\n    private siblingRank: number;\n\n    constructor(range: Range,\n                extra_data: Record<string, any> = {}) {\n        this.range = range;\n        this.parent = null;\n        this.children = [];\n        this.extra_data = extra_data;\n        this.innerRangeOverride = null;\n        this.siblingRank = 0;\n    }\n\n    /**\n     * Gets the range of this node in the source code.\n     * @returns The range, which corresponds to a substring of the source code.\n     */\n    getRange(): Range {\n        return this.range;\n    }\n\n    /**\n     * Overrides the default computation of inner range.\n     * @param range The range to override the inner range with.\n     */\n    overrideInnerRange(range: Range) {\n        if (!contains(this.range, range)) {\n            throw Error(\"Inner range must be (not necessarily strictly) contained inside the full range!\");\n        }\n        this.innerRangeOverride = range;\n    }\n\n    /**\n     * Gets the inner range of this node, encompassing all immediate children's ranges.\n     * Returns null if the node has no children.\n     * @returns The inner range.\n     */\n    getInnerRange(): Range | null {\n        if (this.innerRangeOverride !== null) {\n            return this.innerRangeOverride;\n        }\n        if (!this.hasChildren()) return null;\n        const childrenRanges = this.children.map(child => child.getRange());\n        return mergeRanges(childrenRanges);\n    }\n\n    /**\n     * Returns the prefix range, which is the first connected component of getRange() - getInnerRange()\n     * @returns The prefix range.\n     */\n    getPrefixRange(): Range | null {\n        const innerRange = this.getInnerRange();\n        if (innerRange === null) {\n            return null;\n        }\n        return indexesToRange(rangeToIndexes(this.range).start, rangeToIndexes(innerRange).start);\n    }\n\n    /**\n     * Returns the suffix range, which is the second connected component of getRange() - getInnerRange()\n     * @returns The suffix range.\n     */\n    getSuffixRange(): Range | null {\n        const innerRange = this.getInnerRange();\n        if (innerRange === null) {\n            return null;\n        }\n        return indexesToRange(rangeToIndexes(innerRange).end, rangeToIndexes(this.range).end);\n    }\n\n    /**\n     * Determines if the node has children.\n     */\n    hasChildren(): boolean {\n        return this.children.length > 0;\n    }\n\n    /**\n     * Sets the parent of this node.\n     * @param node The parent node.\n     */\n    setParent(node: SyntaxNode | null): void {\n        this.parent = node;\n    }\n\n    /**\n     * Gets the parent of this node.\n     * @returns The parent node or null.\n     */\n    getParent(): SyntaxNode | null {\n        return this.parent;\n    }\n\n    /**\n     * Adds a child to this node.\n     * @param node The child node to add.\n     */\n    addChild(node: SyntaxNode): void {\n        node.setParent(this);\n        node.siblingRank = this.children.length;\n        this.children.push(node);\n    }\n\n    /**\n     * Gets the rank among the siblings\n     * @returns The rank.\n     */\n    getSiblingRank(): number {\n        return this.siblingRank;\n    }\n\n    /**\n     * Lists all immediate children of this node.\n     * @returns An array of child nodes.\n     */\n    listChildren(): SyntaxNode[] {\n        return this.children.slice();\n    }\n\n    /**\n     * Asserts the children's ranges are valid.\n     */\n    assertRangeValid(): void {\n        for (const child of this.children) {\n            if (!contains(this.range, child.range)) {\n                throw Error(\"Invalid range! Expected child range to be inside this.range.\");\n            }\n        }\n    }\n\n    /**\n     * Gets the depth of itself in the tree.\n     */\n    getDepth(): number {\n        if (this.parent === null) {\n            return 0;\n        }\n        return this.parent.getDepth() + 1;\n    }\n}","import { SyntaxNode } from \"./SyntaxNode\";\nimport { Range } from \"../utils\";\n\nexport class Argument extends SyntaxNode {\n    public argumentName: string;\n    public argumentType: string | null;\n\n    constructor(\n        range: Range,\n        argumentName: string,\n        argumentType: string | null = null,\n        extra_data: Record<string, any> = {}\n    ) {\n        super(range, extra_data);\n        this.argumentName = argumentName;\n        this.argumentType = argumentType;\n    }\n}","import { SyntaxNode } from \"./SyntaxNode\";\nimport { Range } from \"../utils\";\n\nexport class Attributes extends SyntaxNode {\n    public attributeName: string;\n    public attributeType: string | null;\n\n    constructor(\n        range: Range,\n        attributeName: string,\n        attributeType: string | null = null,\n        extra_data: Record<string, any> = {}\n    ) {\n        super(range, extra_data);\n        this.attributeName = attributeName;\n        this.attributeType = attributeType;\n    }\n}","import { SyntaxNode } from \"./SyntaxNode\";\nimport { Range } from \"../utils\";\n\nexport class Classes extends SyntaxNode {\n    public classType: string | null;\n    public classDefinitionText: string;\n\n    constructor(\n        range: Range,\n        classType: string | null,\n        classDefinitionText: string,\n        extra_data: Record<string, any> = {}\n    ) {\n        super(range, extra_data);\n        this.classType = classType;\n        this.classDefinitionText = classDefinitionText;\n    }\n}\n","import { SyntaxNode } from \"./SyntaxNode\";\nimport { Range } from \"../utils\";\n\nexport class Comments extends SyntaxNode {\n    public isMultiLine: boolean;\n    public commentContents: string;\n    constructor(\n        range: Range,\n        isMultiLine: boolean,\n        commentContents: string,\n        extra_data: Record<string, any> = {}\n    ) {\n        super(range, extra_data);\n        this.isMultiLine = isMultiLine;\n        this.commentContents = commentContents;\n    }\n}","import { SyntaxNode } from \"./SyntaxNode\";\nimport { Range } from \"../utils\";\nimport { Argument } from \"./Argument\";\n\nexport class FunctionDeclaration extends SyntaxNode {\n    public functionName: string;\n    public functionReturnType: string | null;\n\n    constructor(\n        range: Range,\n        functionName: string,\n        functionReturnType: string | null,\n        extra_data: Record<string, any> = {}\n    ) {\n        super(range, extra_data);\n        this.functionName = functionName;\n        this.functionReturnType = functionReturnType;\n    }\n\n    /**\n     * Determines whether this FunctionDeclaration has any arguments.\n     * @returns True if there are Argument children, false otherwise.\n     */\n    hasArguments(): boolean {\n        return this.children.some(child => child instanceof Argument);\n    }\n}\n","import { Range } from \"../utils\";\nimport { SyntaxNode } from \"./SyntaxNode\";\nimport { Comments } from \"./Comments\";\n\nexport class FunctionGroups extends SyntaxNode {\n\n    constructor(range: Range, extra_data: Record<string, any> = {}) {\n        super(range, extra_data);\n    }\n\n    /**\n     * Checks if this FunctionGroup contains a Comment node.\n     * @returns True if a Comment is present, false otherwise.\n     */\n    hasComment(): boolean {\n        return this.children.some(child => child instanceof Comments);\n    }\n}\n","import { SyntaxNode } from \"./SyntaxNode\";\nimport { Range } from \"../utils\";\n\nexport class Functions extends SyntaxNode {\n    public functionDefinitionText: string;\n    private funcBodyNonEmpty: boolean;\n\n    constructor(\n        range: Range,\n        functionDefinitionText: string,\n        extra_data: Record<string, any> = {}\n    ) {\n        super(range, extra_data);\n        this.functionDefinitionText = functionDefinitionText;\n        this.funcBodyNonEmpty = false;\n    }\n\n    public hasFunctionBody(): boolean {\n        return this.funcBodyNonEmpty;\n    }\n\n    public flagHaveFunctionBody(): void {\n        this.funcBodyNonEmpty = true;\n    }\n}\n","import { SyntaxNode } from \"./SyntaxNode\";\nimport { Range } from \"../utils\";\n\nexport class References extends SyntaxNode {\n    public referenceText: string;\n    public refRelativePath: string | null;\n\n    constructor(\n        range: Range,\n        referenceText: string,\n        refRelativePath: string | null,\n        extra_data: Record<string, any> = {}\n    ) {\n        super(range, extra_data);\n        this.referenceText = referenceText;\n        this.refRelativePath = refRelativePath;\n    }\n}\n","import { SyntaxNode } from \"./SyntaxNode\";\nimport { Range } from \"../utils\";\n\nexport class TopLevel extends SyntaxNode {\n    \n    constructor(range: Range, extra_data: Record<string, any> = {}) {\n        super(range, extra_data);\n    }\n    \n}\n","export class CodeParserImplError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"CodeParsingError\";\n    }\n}","import { Classes, Functions, SyntaxNode } from \"../nodes\";\nimport { AbstractSyntaxTree } from \"./AbstractSyntaxTree\";\nimport { contains, compare, Range, Index, rangeToStartIndex, rangeToEndIndex, rangeToIndexes, indexesToRange, getMaxRange } from \"../utils\";\nimport { CodeParserImplError } from \"../CodeParserImplError\";\n\nexport enum TreeTokenType {\n    TOP_LEVEL,\n    REFERENCES,\n    FUNCTION_GROUP,\n    FUNCTION,\n    FUNCTION_DEFINITION,\n    COMMENTS,\n    CLASS,\n    ATTRIBUTE,\n    ARGUMENT,\n    OTHERS\n};\n\nexport type TreeToken = {\n    stringContents: string;\n    tokenType: TreeTokenType;\n    range?: Range;\n    originalNode?: SyntaxNode;\n};\n\nexport enum TokenAction {\n    TERMINATE, // stop resolving child nodes\n    RESOLVE // keep resolving child nodes\n};\n\nexport type TextRange = {\n    text: string,\n    range: Range\n};\n\nexport abstract class ASTGenericTokenizer {\n    public static tokensToString(tokens: TreeToken[]): string {\n        let result = \"\";\n        for (const tok of tokens) {\n            result += tok.stringContents;\n        }\n        return result;\n    }\n\n    private tree: AbstractSyntaxTree | null;\n    private tokenString: TreeToken[];\n    private start: Index;\n    private end: Index;\n\n    private subtreeRestrictionPath: SyntaxNode[] | null;\n    private nodeToReplace: SyntaxNode | null;\n    private replacementString: string | null;\n\n    private nodeToReplaceTokenIdx: number;\n    private fillTokens: boolean;\n\n    constructor() {\n        this.tree = null;\n        this.tokenString = [];\n        this.start = {line: 0, character: 0};\n        this.end = {line: 0, character: 0};\n\n        this.subtreeRestrictionPath = null;\n        this.nodeToReplace = null;\n        this.replacementString = null;\n\n        this.nodeToReplaceTokenIdx = -1;\n        this.fillTokens = true;\n    }\n\n    /**\n     * Uses a tree recursion algorithm to tokenize the tree.\n     * @param tree\n     * @param fillContents Whether to fill the contents of functions. Ignored if using ASTFaithfulTokenizer.\n     */\n    tokenize(tree: AbstractSyntaxTree, fillTokens: boolean=true): TreeToken[] {\n        this.tree = tree;\n        this.tokenString = [];\n        ({start: this.start, end: this.end} = tree.getMaxRangeAsIndices());\n        this.subtreeRestrictionPath = null;\n        this.nodeToReplace = null;\n        this.replacementString = null;\n\n        this.nodeToReplaceTokenIdx = -1;\n        this.fillTokens = fillTokens;\n\n        this.pretokenize(this.tokenString);\n        this.recursivelyTokenize(tree.getRoot(), 0, null);\n        this.posttokenize(this.tokenString);\n\n        return this.tokenString;\n    }\n\n    /**\n     * Tokenizes the subtree starting at the starting node.\n     * @param tree The AST\n     * @param start The root node\n     * @param includeParents Whether to include also the parents of the token.\n     * @param fillContents Whether to fill the contents of functions. Ignored if using ASTFaithfulTokenizer.\n     */\n    tokenizeSubtree(tree: AbstractSyntaxTree, start: SyntaxNode, includeParents: boolean, fillTokens: boolean=true): TreeToken[] {\n        if (start === tree.getRoot()) {\n            return this.tokenize(tree); // not really a subtree\n        }\n\n        if (this.disableSubtreeParsing()) {\n            throw Error(\"Subtree parsing is not allowed for this AST tokenizer!\");\n        }\n\n        this.tree = tree;\n        this.tokenString = [];\n        ({start: this.start, end: this.end} = tree.getMaxRangeAsIndices());\n        this.nodeToReplace = null;\n        this.replacementString = null;\n\n        this.nodeToReplaceTokenIdx = -1;\n        this.fillTokens = fillTokens;\n\n        if (includeParents) {\n            this.subtreeRestrictionPath = [];\n            const tempList: SyntaxNode[] = [];\n            for (let i = 0; i < start.getDepth(); i++) {\n                if (i === 0) {\n                    tempList.push(start);\n                } else {\n                    tempList.push(tempList[tempList.length - 1].getParent()!);\n                }\n            }\n            for (let i = 0; i < tempList.length; i++) {\n                this.subtreeRestrictionPath.push(tempList[tempList.length - 1 - i]);\n            }\n\n            // recursively tokenize from the root, but along the specified path, and then into the desired token\n            this.pretokenize(this.tokenString);\n            this.recursivelyTokenize(tree.getRoot(), 0, null, this.subtreeRestrictionPath[0]);\n            this.posttokenize(this.tokenString);\n        } else {\n            this.subtreeRestrictionPath = null;\n            this.pretokenize(this.tokenString);\n            this.includeIndentation(this.tokenString, start.getDepth());\n            this.recursivelyTokenize(start, start.getDepth(), null);\n            this.posttokenize(this.tokenString);\n        }\n\n        return this.tokenString;\n    }\n\n    /**\n     * Uses a tree recursion algorithm to tokenize the tree. When the nodeToReplace is being resolved, instead of resolving the\n     * node as usual, replace its contents entirely with replacementString and terminate resolving the subtree of nodeToReplace.\n     * @param tree The tree\n     * @param nodeToReplace The node to replace\n     * @param replacementString The string it should be replaced with\n     */\n    tokenizeReplaceNode(tree: AbstractSyntaxTree, nodeToReplace: SyntaxNode, replacementString: string): TreeToken[] {\n        this.tree = tree;\n        this.tokenString = [];\n        ({start: this.start, end: this.end} = tree.getMaxRangeAsIndices());\n        this.subtreeRestrictionPath = null;\n        this.nodeToReplace = nodeToReplace;\n        this.replacementString = replacementString;\n\n        this.nodeToReplaceTokenIdx = -1;\n        this.fillTokens = true;\n\n        this.pretokenize(this.tokenString);\n        this.recursivelyTokenize(tree.getRoot(), 0, null);\n        this.posttokenize(this.tokenString);\n\n        return this.tokenString;\n    }\n\n    /**\n     * Uses a tree recursion algorithm to tokenize the tree. When the nodeToReplace is being resolved, instead of resolving the\n     * node as usual, replace its contents with a placeholder, and record the index. Returns the token list and the placeholder token idx.\n     * @param tree The tree\n     * @param nodeToReplace The node to replace\n     * @returns The token list and the placeholder token index. If not found, foundTokenIdx will be -1.\n     */\n    tokenizeTargetNode(tree: AbstractSyntaxTree, nodeToReplace: SyntaxNode): {tokList: TreeToken[], foundTokenIdx: number} {\n        this.tree = tree;\n        this.tokenString = [];\n        ({start: this.start, end: this.end} = tree.getMaxRangeAsIndices());\n        this.subtreeRestrictionPath = null;\n        this.nodeToReplace = nodeToReplace;\n        this.replacementString = null;\n\n        this.nodeToReplaceTokenIdx = -1;\n        this.fillTokens = true;\n\n        this.pretokenize(this.tokenString);\n        this.recursivelyTokenize(tree.getRoot(), 0, null);\n        this.posttokenize(this.tokenString);\n\n        return {tokList: this.tokenString, foundTokenIdx: this.nodeToReplaceTokenIdx};\n    }\n\n    protected needsFillTokens(): boolean {\n        return this.fillTokens;\n    }\n\n    /**\n     * Gets the different texts from the syntax node.\n     * @param node The syntax node\n     * @returns tokenText, tokenPrefixText and tokenSuffixText\n     */\n    public getTexts(node: SyntaxNode): { tokenText: TextRange, tokenPrefixText: TextRange | null, tokenSuffixText: TextRange | null } {\n        const range: Range = node.getRange();\n        const prefixRange: Range | null = node.getPrefixRange();\n        const suffixRange: Range | null = node.getSuffixRange();\n\n        if ((node instanceof Functions) || (node instanceof Classes)) {\n            if (prefixRange === null || suffixRange === null) {\n                throw new CodeParserImplError(\"The Parser must implement and resolve the inner range for Functions and Classes! This is the maximal inner range so that when taken away, the class/function is still a valid class/function (with no body).\");\n            }\n        }\n\n        const tokenText: string = this.tree!.getSourceTextFromRange(range);\n        let tokenPrefixText: TextRange | null = null;\n        let tokenSuffixText: TextRange | null = null;\n        if (prefixRange !== null && compare(rangeToStartIndex(prefixRange), rangeToEndIndex(prefixRange)) === -1) {\n            tokenPrefixText = {text: this.tree!.getSourceTextFromRange(prefixRange), range: prefixRange};\n        }\n        if (suffixRange !== null && compare(rangeToStartIndex(suffixRange), rangeToEndIndex(suffixRange)) === -1) {\n            tokenSuffixText = {text: this.tree!.getSourceTextFromRange(suffixRange), range: suffixRange};\n        }\n\n        return { tokenText: {text: tokenText, range: range}, tokenPrefixText: tokenPrefixText, tokenSuffixText: tokenSuffixText };\n    }\n\n\n    private recursivelyTokenize(node: SyntaxNode, depth: number, previousNode: SyntaxNode | null, resolveRestrictionNode: SyntaxNode | null = null): void {\n        if (this.nodeToReplace !== null && node === this.nodeToReplace) {\n            // ok, simply replace with replacement string\n            const repStr: string = (this.replacementString === null) ? \"[PLACEHOLDER/ERROR: Didn't provide replacement string!]\" : this.replacementString;\n            this.tokenString.push({stringContents: repStr, tokenType: TreeTokenType.OTHERS});\n            this.nodeToReplaceTokenIdx = this.tokenString.length - 1;\n            return;\n        }\n\n        const { tokenText, tokenPrefixText, tokenSuffixText } = this.getTexts(node);\n        const {prefixTokens, suffixTokens, action } = this.convertIntoTokens(node, depth, previousNode, tokenText, tokenPrefixText, tokenSuffixText);\n        if (prefixTokens !== undefined) {\n            for (const tok of prefixTokens) {\n                this.tokenString.push(tok);\n            }\n        }\n\n        if (action === TokenAction.RESOLVE) {\n            let prevChild: SyntaxNode | null = null;\n            for (const child of node.listChildren()) {\n                if (resolveRestrictionNode === null || child === resolveRestrictionNode) { // resolve the child only if there are no restrictions, or if it is the resolve restriction node\n                    let subRestrictionNode: SyntaxNode | null = null;\n                    if (this.subtreeRestrictionPath !== null && depth + 1 < this.subtreeRestrictionPath.length) {\n                        subRestrictionNode = this.subtreeRestrictionPath[depth + 1];\n                    }\n                    this.recursivelyTokenize(child, depth + 1, prevChild, subRestrictionNode);\n                    prevChild = child;\n                }\n            }\n        }\n\n        if (suffixTokens !== undefined) {\n            if (suffixTokens.length > 0) {\n                const additionalToken: TreeToken | null = this.handleFirstSuffixTokenIfNecessary(suffixTokens[0]);\n                if (additionalToken !== null)\n                    this.tokenString.push(additionalToken);\n            }\n\n            let lstWithRange: TreeToken | null = null;\n            for (const tok of suffixTokens) {\n                this.tokenString.push(tok);\n                if (tok.range !== undefined) {\n                    lstWithRange = tok;\n                }\n            }\n\n            if (lstWithRange !== null) {\n                this.handleLastSuffixTokenWithRangeIfNecessary(lstWithRange);\n            }\n        }\n    }\n\n    /**\n     * Whether to disable subtree parsing. Override this and return true if its not allowed.\n     * @returns Whether to disable subtree parsing.\n     */\n    protected disableSubtreeParsing(): boolean {\n        return false;\n    }\n\n    /**\n     * Gets the code string from the range\n     * @param range The range\n     * @returns The source text within the range\n     */\n    protected getCodeString(range: Range): string {\n        return this.tree!.getSourceTextFromRange(range);\n    }\n\n    /**\n     * Gets the code string within the start and end indices.\n     * @param start The start index (inclusive)\n     * @param end The end index (non-inclusive)\n     * @returns The source text\n     */\n    protected getCodeStringFromIndices(start: Index, end: Index): string {\n        return this.getCodeString(indexesToRange(start, end));\n    }\n\n    /**\n     * Gets the global start index of the code which is always (0, 0).\n     * @returns The global start index.\n     */\n    protected getGlobalStartIndex(): Index {\n        return this.start;\n    }\n\n    /**\n     * Gets the global end index of the code which is always (numCodeLines, 0).\n     * @returns The global end index\n     */\n    protected getGlobalEndIndex(): Index {\n        return this.end;\n    }\n\n    /**\n     * Add a token before the first suffix token if necessary. Does not have to be overridden.\n     * Default behaviour returns null, which means no token is needed to be added.\n     * @param firstSuffixToken The first suffix token to be added after the returned (if any) token.\n     * @returns A TreeToken or null.\n     */\n    protected handleFirstSuffixTokenIfNecessary(firstSuffixToken: TreeToken): TreeToken | null {\n        return null;\n    }\n\n    /**\n     * Add a token before the first suffix token if necessary. Does not have to be overridden.\n     * Default behaviour returns null, which means no token is needed to be added.\n     * @param lastSuffixTokenWithRange The last suffix token with range\n     */\n    protected handleLastSuffixTokenWithRangeIfNecessary(lastSuffixTokenWithRange: TreeToken): void {\n        \n    }\n\n    /**\n     * Convert the node to tokens. If action is TERMINATE, the subnodes of the node won't be resolved. In this case, there is no difference between prefixTokens and suffixTokens, they\n     * will be appended together in sequential fashion from prefixTokens to suffixTokens. If action is RESOLVE, the subnodes of the node will be resolved. The prefixTokens will be appended\n     * first, and then the tokens because of the resolvation of the subnodes, and then the suffixTokens. \n     * @param node The syntax node being resolved. Use .getParent() to get its parent if depth >= 1.\n     * @param depth The depth of the current node.\n     * @param previousNode The previous sibling node being resolved, if exists.\n     * @param tokenText The text of the current node, obtained with .getRange(). Also contains the range.\n     * @param tokenPrefixText The prefix text of the current node, if exists, obtained with .getPrefixRange(). Also contains the corresponding range.\n     * @param tokenSuffixText The suffix text of the current node, if exists, obtained with .getSuffixRange(). Also contains the corresponding range.\n     */\n    protected abstract convertIntoTokens(\n        node: SyntaxNode,\n        depth: number,\n        previousNode: SyntaxNode | null,\n        tokenText: TextRange,\n        tokenPrefixText: TextRange | null,\n        tokenSuffixText: TextRange | null\n    ): {prefixTokens?: TreeToken[], suffixTokens?: TreeToken[], action: TokenAction};\n\n    protected abstract pretokenize(tokenString: TreeToken[]): void;\n    protected abstract posttokenize(tokenString: TreeToken[]): void;\n    protected abstract includeIndentation(tokenString: TreeToken[], depth: number): void;\n}","import { TreeToken, TreeTokenType } from \"../parsing/ASTGenericTokenizer\";\nimport { Argument, Attributes, Classes, Comments, FunctionDeclaration, Functions, References, SyntaxNode, TopLevel } from \"../nodes\";\n\nconst TOKEN_COLORS: { [key in TreeTokenType]: string[] } = {\n    [TreeTokenType.ARGUMENT]: [\"#FFF8DC\", \"#EFE8CC\"], // Cornsilk\n    [TreeTokenType.ATTRIBUTE]: [\"#E0FFFF\", \"#D0EFEF\"], // Light Cyan\n    [TreeTokenType.CLASS]: [\"#FFE4E1\", \"#EFD4D1\"], // Misty Rose\n    [TreeTokenType.COMMENTS]: [\"#F0FFF0\", \"#E0EFE0\"], // Honeydew\n    [TreeTokenType.FUNCTION]: [\"#F5F5DC\", \"#E5E5CC\"], // Beige\n    [TreeTokenType.FUNCTION_DEFINITION]: [\"#F0F8FF\", \"#E0E8EF\"], // Alice Blue\n    [TreeTokenType.FUNCTION_GROUP]: [\"#FAFAD2\", \"#EAEAC2\"], // Light Goldenrod Yellow\n    [TreeTokenType.OTHERS]: [\"#FFFFFF\", \"#EFEFEF\"], // White\n    [TreeTokenType.REFERENCES]: [\"#FFF0F5\", \"#EFE0E5\"], // Lavender Blush\n    [TreeTokenType.TOP_LEVEL]: [\"#F5FFFA\", \"#E5EFEA\"]  // Mint Cream\n};\n\nclass TreeTokenVisualizer extends HTMLElement {\n    private tokens: TreeToken[] = [];\n    private container: HTMLElement;\n    private hoverDiv: HTMLElement | null = null; // Reference to the hover div\n\n    constructor(initialTokens: TreeToken[] = []) {\n        super();\n        this.attachShadow({ mode: \"open\" });\n\n        // Create a container for the tokens\n        this.container = document.createElement(\"div\");\n        this.container.style.fontFamily = \"monospace\";\n        this.container.style.whiteSpace = \"pre-wrap\"; // Preserve whitespace and line breaks\n        this.container.style.padding = \"10px\";\n        this.container.style.border = \"1px solid #ccc\";\n        this.container.style.borderRadius = \"4px\";\n        this.shadowRoot!.appendChild(this.container);\n\n        // Initialize with initial tokens\n        if (initialTokens.length > 0) {\n            this.tokens = initialTokens;\n            this.render();\n        }\n    }\n\n    public update(toks: TreeToken[]) {\n        this.tokens = toks;\n        this.render();\n    }\n\n    private getHoverText(token: TreeToken): string | null {\n        if (token.originalNode !== undefined) {\n            const node: SyntaxNode = token.originalNode;\n            if (node instanceof Argument) {\n                return `Type: Argument   Depth: ${node.getDepth()}   Rank: ${node.getSiblingRank()}\nName: ${node.argumentName}   Type: ${node.argumentType}`;\n            } else if (node instanceof Attributes) {\n                return `Type: Attributes   Depth: ${node.getDepth()}   Rank: ${node.getSiblingRank()}\nName: ${node.attributeName}   Type: ${node.attributeType}`;\n            } else if (node instanceof Classes) {\n                return `Type: Classes   Depth: ${node.getDepth()}   Rank: ${node.getSiblingRank()}\nDefinition: ${node.classDefinitionText}\nClass type: ${node.classType}`;\n            } else if (node instanceof Comments) {\n                return `Type: Comments   Depth: ${node.getDepth()}   Rank: ${node.getSiblingRank()}\nContents: ${node.commentContents}\nIs multiline: ${node.isMultiLine}`;\n            } else if (node instanceof FunctionDeclaration) {\n                return `Type: Funct Decl   Depth: ${node.getDepth()}   Rank: ${node.getSiblingRank()}\nName: ${node.functionName}\nReturn type: ${node.functionReturnType}`;\n            } else if (node instanceof Functions) {\n                return `Type: Function   Depth: ${node.getDepth()}   Rank: ${node.getSiblingRank()}\nDefinition: ${node.functionDefinitionText}\nHas body: ${node.hasFunctionBody()}`;\n            } else if (node instanceof References) {\n                return `Type: References   Depth: ${node.getDepth()}   Rank: ${node.getSiblingRank()}\nReference Text: ${node.referenceText}\nReference Path: ${node.refRelativePath}`;\n            } else if (node instanceof TopLevel) {\n                return `Type: Top Level   Depth: ${node.getDepth()}   Rank: ${node.getSiblingRank()}`;\n            }\n        }\n        return null;\n    }\n\n    // Render the tokens into the container\n    private render() {\n        // Clear existing content\n        this.container.innerHTML = \"\";\n\n        const counts: { [key in TreeTokenType]: number } = {\n            [TreeTokenType.ARGUMENT]: 0,\n            [TreeTokenType.ATTRIBUTE]: 0,\n            [TreeTokenType.CLASS]: 0,\n            [TreeTokenType.COMMENTS]: 0,\n            [TreeTokenType.FUNCTION]: 0,\n            [TreeTokenType.FUNCTION_DEFINITION]: 0,\n            [TreeTokenType.FUNCTION_GROUP]: 0,\n            [TreeTokenType.OTHERS]: 0,\n            [TreeTokenType.REFERENCES]: 0,\n            [TreeTokenType.TOP_LEVEL]: 0\n        };\n        const prevNodes: { [key in TreeTokenType]: SyntaxNode | undefined } = {\n            [TreeTokenType.ARGUMENT]: undefined,\n            [TreeTokenType.ATTRIBUTE]: undefined,\n            [TreeTokenType.CLASS]: undefined,\n            [TreeTokenType.COMMENTS]: undefined,\n            [TreeTokenType.FUNCTION]: undefined,\n            [TreeTokenType.FUNCTION_DEFINITION]: undefined,\n            [TreeTokenType.FUNCTION_GROUP]: undefined,\n            [TreeTokenType.OTHERS]: undefined,\n            [TreeTokenType.REFERENCES]: undefined,\n            [TreeTokenType.TOP_LEVEL]: undefined\n        };\n        this.tokens.forEach(token => {\n            const tokenType = token.tokenType;\n            const bgColor = TOKEN_COLORS[tokenType] || \"#ffffff\";\n            const borderColor = \"#00000033\"; // Very soft black border\n            if (token.originalNode === undefined || token.originalNode !== prevNodes[tokenType]) {\n                counts[tokenType]++; // change a bit hue if its undefined or the original node it refers to have changed\n            }\n            prevNodes[tokenType] = token.originalNode;\n\n            // Split the stringContents by '\\n' to handle newlines\n            const parts = token.stringContents.split(\"\\n\");\n            parts.forEach((part, index) => {\n                const span = document.createElement(\"span\");\n                span.textContent = part;\n\n                span.style.backgroundColor = bgColor[counts[tokenType] % 2];\n                span.style.border = `1px solid ${borderColor}`;\n                span.style.borderRadius = \"3px\";\n                span.style.padding = \"2px 4px\";\n                span.style.margin = \"1px\";\n                span.style.display = \"inline-block\";\n\n                // Add hover event listeners to the span\n                span.style.position = \"relative\";\n\n                span.addEventListener(\"mouseenter\", (event) => {\n                    const hoverText = this.getHoverText(token);\n                    if (hoverText) {\n                        this.showHoverDiv(event.currentTarget as HTMLElement, hoverText);\n                    }\n                });\n\n                span.addEventListener(\"mouseleave\", () => {\n                    this.hideHoverDiv();\n                });\n\n                if (index < parts.length - 1) {\n                    span.textContent = span.textContent + \"\\\\n\";\n                    this.container.appendChild(span);\n                    this.container.appendChild(document.createElement(\"br\"));\n                } else {\n                    if (span.textContent.length > 0) {\n                        this.container.appendChild(span);\n                    }\n                }\n            });\n        });\n    }\n\n    private showHoverDiv(target: HTMLElement, text: string) {\n        // Ensure any existing hoverDiv is removed\n        this.hideHoverDiv();\n    \n        // Create the hover div\n        this.hoverDiv = document.createElement(\"div\");\n        \n        // Split the text into lines\n        const lines = text.split('\\n');\n    \n        // Append each line as a separate div\n        lines.forEach(line => {\n            const lineElement = document.createElement(\"div\");\n            lineElement.textContent = line;\n            this.hoverDiv!.appendChild(lineElement);\n        });\n    \n        // Style the hover div\n        this.hoverDiv.style.position = \"absolute\";\n        this.hoverDiv.style.backgroundColor = \"#ffffff\";\n        this.hoverDiv.style.border = \"1px solid #ccc\";\n        this.hoverDiv.style.borderRadius = \"4px\";\n        this.hoverDiv.style.padding = \"8px\";\n        this.hoverDiv.style.boxShadow = \"0px 2px 8px rgba(0, 0, 0, 0.1)\";\n        this.hoverDiv.style.whiteSpace = \"pre-wrap\";\n        this.hoverDiv.style.textAlign = \"left\";\n        this.hoverDiv.style.zIndex = \"10\";\n        this.hoverDiv.style.width = \"auto\"; // Allow dynamic width based on content\n        this.hoverDiv.style.height = \"auto\"; // Allow dynamic height based on content\n    \n        // Optionally, add a smooth transition for dynamic resizing\n        this.hoverDiv.style.transition = \"all 0.3s ease\";\n    \n        // Position the hover div relative to the target element\n        const rect = target.getBoundingClientRect();\n        const shadowRect = this.shadowRoot!.host.getBoundingClientRect();\n    \n        // Calculate the top and left positions\n        const topPosition = rect.bottom - shadowRect.top + 5;\n        const leftPosition = rect.left - shadowRect.left;\n    \n        this.hoverDiv.style.top = `${topPosition}px`;\n        this.hoverDiv.style.left = `${leftPosition}px`;\n    \n        // Append the hover div to the shadow root\n        this.shadowRoot!.appendChild(this.hoverDiv);\n    }\n    \n    // Method to hide and remove the hover div\n    private hideHoverDiv() {\n        if (this.hoverDiv) {\n            this.hoverDiv.remove();\n            this.hoverDiv = null;\n        }\n    }\n}\n\n// Export the class if needed elsewhere\nexport { TreeTokenVisualizer };","import { Token, TokenType } from \"./ParsingTypes\";\n\nexport abstract class AbstractTokenizer {\n    private tokenString: Token[];\n    private stringBuffer: string;\n    private charIdx: number;\n    private tokStartIdx: number;\n    private ended: boolean;\n\n    constructor() {\n        this.tokenString = [];\n        this.stringBuffer = \"\";\n        this.charIdx = 0;\n        this.tokStartIdx = 0;\n        this.ended = false;\n    }\n\n    public reset(): void {\n        this.tokenString = [];\n        this.stringBuffer = \"\";\n        this.charIdx = 0;\n        this.tokStartIdx = 0;\n        this.ended = false;\n        this.onReset();\n    }\n\n\n    /**\n     * Gives the next character in the character stream, with null indicating the end of the sequence.\n     * @param ch The new character.\n     */\n    public next(ch: string | null) {\n        if (this.ended) {\n            throw Error(\"Cannot call next when already ended! Must reset with .reset().\");\n        }\n        if (ch === null) {\n            // handle remanining \n            if (this.charIdx > this.tokStartIdx) {\n                this.tokenString.push({tokenType: this.matchEndCharacter(), stringContents: this.stringBuffer, characterRange: {start: this.tokStartIdx, end: this.charIdx}});\n            }\n            this.ended = true;\n        } else {\n            if (ch.length !== 1) {\n                throw Error(\"Character stream to be fed into AbstractTokenizer must have length 1!\");\n            }\n\n            this.stringBuffer += ch;\n            this.charIdx++;\n            const matchResult: {type: TokenType, singleChType?: TokenType, numSplitCharacters?: number} | null = this.matchNext(ch);\n            if (matchResult !== null) {\n                if (matchResult.type === TokenType.CONTINUATION) {\n                    throw Error(\"Only singleChType can be continuation!\");\n                }\n\n                const length: number = this.charIdx - this.tokStartIdx;\n                if (matchResult.singleChType === undefined) {\n                    // Add a single token with string encapsulating the entire string buffer.\n                    this.tokenString.push({tokenType: matchResult.type,\n                        stringContents: this.stringBuffer,\n                        characterRange: {start: this.tokStartIdx, end: this.charIdx}});\n                    \n                    // Full reset\n                    this.tokStartIdx = this.charIdx;\n                    this.stringBuffer = \"\";\n                } else {\n                    // We need to split the current string buffer into two parts\n                    if (matchResult.numSplitCharacters === undefined) {\n                        matchResult.numSplitCharacters = 1; // default value 1\n                    }\n                    if (matchResult.numSplitCharacters < 1) {\n                        throw Error(\"numSplitCharacters should be >= 1!\");\n                    }\n                    if (length < matchResult.numSplitCharacters + 1) {\n                        throw Error(\"The length of the buffer (including the newly added character) must be > numSplitCharacters! This is to allow splitting the buffer into two parts which are non-empty.\");\n                    }\n\n                    // Now we split the buffer into two parts. If the buffer is [0, buf_len), then the two parts are [0, buf_len - numSplitCharacters), [buf_len - numSplitCharacters, buf_len)\n                    if (matchResult.singleChType === TokenType.CONTINUATION) {\n                        // Add a single token as the first split, while the second split will be stored as the new buffer\n                        this.tokenString.push({tokenType: matchResult.type,\n                            stringContents: this.stringBuffer.substring(0, this.stringBuffer.length - matchResult.numSplitCharacters),\n                            characterRange: {start: this.tokStartIdx, end: this.charIdx - matchResult.numSplitCharacters}});\n\n                        // Partial reset, keep the last token.\n                        this.tokStartIdx = this.charIdx - matchResult.numSplitCharacters;\n                        this.stringBuffer = this.stringBuffer.substring(this.stringBuffer.length - matchResult.numSplitCharacters, this.stringBuffer.length);\n                    } else {\n                        // Add two tokens corresponding to the split\n                        this.tokenString.push({tokenType: matchResult.type,\n                            stringContents: this.stringBuffer.substring(0, this.stringBuffer.length - matchResult.numSplitCharacters),\n                            characterRange: {start: this.tokStartIdx, end: this.charIdx - matchResult.numSplitCharacters}});\n                        this.tokenString.push({tokenType: matchResult.singleChType,\n                                                stringContents: this.stringBuffer.substring(this.stringBuffer.length - matchResult.numSplitCharacters, this.stringBuffer.length),\n                                                characterRange: {start: this.charIdx - matchResult.numSplitCharacters, end: this.charIdx}});\n                        \n                        // Full reset\n                        this.tokStartIdx = this.charIdx;\n                        this.stringBuffer = \"\";\n                    }\n                }\n            }\n        }\n    }\n\n    public getTokens(): Token[] {\n        return this.tokenString;\n    }\n\n    public currentBufferSingleCharacter(): boolean {\n        return this.stringBuffer.length === 1;\n    }\n\n    public currentBufferLength(): number {\n        return this.stringBuffer.length;\n    }\n\n    /**\n     * Depending on the next character in the string, either take some action on the\n     * character buffer, or do nothing (return null). For an action, when including\n     * the whole character buffer (including the newest character) into a token,\n     * return an object with singleChType and numSplitCharacters undefined.\n     * \n     * When excluding the newest character as an independent token, return an object\n     * with type and singleChType given, but numSplitCharacters undefined.\n     * \n     * When excluding a fixed length as an independent token, and adding two tokens,\n     * give type (first token), singleChType (for second token) and numSplitCharacters\n     * that specify the length of the second token.\n     * \n     * To tell the tokenizer to keep a suffix specified by a fixed length in the buffer,\n     * and conclude the rest into a token (exactly one token is created), and then the\n     * aforementioned suffix will be the new buffer, set singleChType to CONTINUATION\n     * @param ch The next character in the string.\n     * @returns The action to be taken.\n     */\n    protected abstract matchNext(ch: string): {type: TokenType, singleChType?: TokenType, numSplitCharacters?: number} | null;\n    protected abstract matchEndCharacter(): TokenType;\n    protected abstract onReset(): void;\n}","import { AbstractTokenizer } from \"../../parsing/AbstractTokenizer\";\nimport { Token, TokenType } from \"../../parsing/ParsingTypes\";\n\nenum StringOrMultilineStatus {\n    NONE = \"NONE\",\n    SINGLE_QUOTES = \"SINGLE_QUOTES\",\n    DOUBLE_QUOTES = \"DOUBLE_QUOTES\",\n    TRIPLE_SINGLE_QUOTES = \"TRIPLE_SINGLE_QUOTES\",\n    TRIPLE_DOUBLE_QUOTES = \"TRIPLE_DOUBLE_QUOTES\"\n}\n\nexport class PythonTokenizer extends AbstractTokenizer {\n    private insideSingleLineComments: boolean;\n    private insideStringStatus: StringOrMultilineStatus;\n    private previousIsEscape: boolean;\n    private contiguousQuotesCount: number;\n\n    constructor() {\n        super();\n\n        this.insideStringStatus = StringOrMultilineStatus.NONE;\n        this.insideSingleLineComments = false;\n        this.previousIsEscape = false;\n        this.contiguousQuotesCount = 0;\n    }\n\n    protected matchNext(ch: string): {type: TokenType, singleChType?: TokenType} | null {\n        if (this.insideSingleLineComments) {\n            // await newline\n            if (ch === \"\\n\") {\n                this.insideSingleLineComments = false;\n                return {type: TokenType.SINGLELINE_COMMENTS, singleChType: TokenType.SPACINGS};\n            }\n            return null;\n        } else if (this.insideStringStatus === StringOrMultilineStatus.SINGLE_QUOTES) {\n            return this.handleSingleQuoteSituation(ch);\n        } else if (this.insideStringStatus === StringOrMultilineStatus.DOUBLE_QUOTES) {\n            return this.handleDoubleQuoteSituation(ch);\n        } else if (this.insideStringStatus === StringOrMultilineStatus.TRIPLE_SINGLE_QUOTES) {\n            return this.handleTripleSingleQuoteSituation(ch);\n        } else if (this.insideStringStatus === StringOrMultilineStatus.TRIPLE_DOUBLE_QUOTES) {\n            return this.handleTripleDoubleQuoteSituation(ch);\n        } else {\n            const situation = this.handleOtherSituation(ch); // represents the token type of the single character, if applicable. else null.\n            if (this.currentBufferSingleCharacter()) {\n                if (situation.tokenType !== null) {\n                    // current buffer single character, and we add the single character\n                    return {type: situation.tokenType};\n                } else {\n                    // the current character belongs to a token with possibly more things. can't determine now\n                    return null;\n                }\n            } else {\n                if (situation.tokenType === null) {\n                    if (situation.isPlainCharacter) {\n                        // the current character continues the OTHERS type token.\n                        return null;\n                    } else {\n                        // the current buffer has things before, but the new charcter is a start of\n                        // a new stuff. we therefore save the previous, and the current token continues with current character\n                        return {type: TokenType.OTHERS, singleChType: TokenType.CONTINUATION};\n                    }\n                } else {\n                    // add both tokens, the previous stuff, and the token representing the current character\n                    return {type: TokenType.OTHERS, singleChType: situation.tokenType};\n                }\n            }\n        }\n    }\n\n    protected matchEndCharacter(): TokenType {\n        if (this.insideSingleLineComments) {\n            return TokenType.SINGLELINE_COMMENTS;\n        } else if (this.insideStringStatus === StringOrMultilineStatus.SINGLE_QUOTES || this.insideStringStatus === StringOrMultilineStatus.DOUBLE_QUOTES) {\n            return TokenType.STRINGS;\n        } else if (this.insideStringStatus === StringOrMultilineStatus.TRIPLE_DOUBLE_QUOTES || this.insideStringStatus === StringOrMultilineStatus.TRIPLE_SINGLE_QUOTES) {\n            return TokenType.MULTILINE_COMMENTS_OR_STRINGS;\n        } else {\n            return TokenType.OTHERS;\n        }\n    }\n\n    protected onReset(): void {\n        this.insideStringStatus = StringOrMultilineStatus.NONE;\n        this.insideSingleLineComments = false;\n        this.previousIsEscape = false;\n        this.contiguousQuotesCount = 0;\n    }\n\n    private handleSingleQuoteSituation(ch: string): {type: TokenType, singleChType?: TokenType} | null {\n        // single quotes. if contiguous, try to upgrade to triple. else await for single closing.\n        if (ch === \"\\'\" && !this.previousIsEscape) { // got single quotes but not escaped yet\n            this.previousIsEscape = false;\n            if (this.contiguousQuotesCount == 2) { // upgrade to triple quotes\n                this.insideStringStatus = StringOrMultilineStatus.TRIPLE_SINGLE_QUOTES;\n                this.contiguousQuotesCount = 0;\n            } else if (this.contiguousQuotesCount == 1){\n                this.contiguousQuotesCount = 2; // increment quote count\n            } else {\n                this.insideStringStatus = StringOrMultilineStatus.NONE;\n                return {type: TokenType.STRINGS}; // end the single quotes since we've reached the end. include the full string with quotes at both sides\n            }\n        } else if (ch === \"\\n\"){\n            this.previousIsEscape = false;\n            this.contiguousQuotesCount = 0;\n            this.insideStringStatus = StringOrMultilineStatus.NONE;\n            return {type: TokenType.STRINGS, singleChType: TokenType.SPACINGS}; // actually incorrect syntax here, forgot closing quotes before newline.\n        } else { // got any other characters\n            if (this.contiguousQuotesCount === 1) {\n                // we got other characters when a single quote is given.\n                this.contiguousQuotesCount = 0;\n            } else if (this.contiguousQuotesCount === 2) {\n                // somehow got two quotes and another character. means that an empty string and something else afterwards\n\n                this.contiguousQuotesCount = 0; // reset all stats and move on to next\n                this.previousIsEscape = false;\n                this.insideStringStatus = StringOrMultilineStatus.NONE;\n\n                const situation = this.handleOtherSituation(ch);\n                if (situation.tokenType === null) {\n                    // the new character is to be continued into the new token\n                    return {type: TokenType.STRINGS, singleChType: TokenType.CONTINUATION}; // end the two single quotes, and do not include the new character\n                } else {\n                    // the new character's token is complete\n                    return {type: TokenType.STRINGS, singleChType: situation.tokenType}; // end the two single quotes as a token, and the new character as a separate token\n                }\n            }\n\n            // for no more contiguous quotes, the new character doesn't matter. just accept characters until closing. we only need to keep track of escapes now\n            if (ch === '\\\\') {\n                this.previousIsEscape = !this.previousIsEscape; // flip it, since double escapes means the second one isn't an escape\n            } else {\n                this.previousIsEscape = false;\n            }\n        }\n        return null;\n    }\n\n    private handleDoubleQuoteSituation(ch: string): {type: TokenType, singleChType?: TokenType} | null {\n        // double quotes. if contiguous, try to upgrade to triple. else await for single closing.\n        if (ch === \"\\\"\" && !this.previousIsEscape) { // got single quotes but not escaped yet\n            this.previousIsEscape = false;\n            if (this.contiguousQuotesCount == 2) { // upgrade to triple quotes\n                this.insideStringStatus = StringOrMultilineStatus.TRIPLE_DOUBLE_QUOTES;\n                this.contiguousQuotesCount = 0;\n            } else if (this.contiguousQuotesCount == 1){\n                this.contiguousQuotesCount = 2; // increment quote count\n            } else {\n                this.insideStringStatus = StringOrMultilineStatus.NONE;\n                return {type: TokenType.STRINGS}; // end the double quotes since we've reached the end. include the full string with quotes at both sides\n            }\n        } else if (ch === \"\\n\"){\n            this.previousIsEscape = false;\n            this.contiguousQuotesCount = 0;\n            this.insideStringStatus = StringOrMultilineStatus.NONE;\n            return {type: TokenType.STRINGS, singleChType: TokenType.SPACINGS}; // actually incorrect syntax here, forgot closing quotes before newline.\n        } else { // got any other characters\n            if (this.contiguousQuotesCount === 1) {\n                // we got other characters when a single quote is given.\n                this.contiguousQuotesCount = 0;\n            } else if (this.contiguousQuotesCount === 2) {\n                // somehow got two quotes and another character. means that an empty string and something else afterwards\n                \n                this.contiguousQuotesCount = 0; // reset all stats and move on to next\n                this.previousIsEscape = false;\n                this.insideStringStatus = StringOrMultilineStatus.NONE;\n\n                const situation = this.handleOtherSituation(ch);\n                if (situation.tokenType === null) {\n                    // the new character is to be continued into the new token\n                    return {type: TokenType.STRINGS, singleChType: TokenType.CONTINUATION}; // end the two single quotes, and do not include the new character\n                } else {\n                    // the new character's token is complete\n                    return {type: TokenType.STRINGS, singleChType: situation.tokenType}; // end the two single quotes as a token, and the new character as a separate token\n                }\n            }\n\n            // for no more contiguous quotes, the new character doesn't matter. just accept characters until closing. we only need to keep track of escapes now\n            if (ch === '\\\\') {\n                this.previousIsEscape = !this.previousIsEscape; // flip it, since double escapes means the second one isn't an escape\n            } else {\n                this.previousIsEscape = false;\n            }\n        }\n        return null;\n    }\n\n    private handleTripleSingleQuoteSituation(ch: string): {type: TokenType, singleChType?: TokenType} | null {\n        // wait until triple single quotes\n        if (ch === \"\\'\" && !this.previousIsEscape) { // got single quotes but not escaped yet\n            this.previousIsEscape = false;\n            if (this.contiguousQuotesCount == 2) {\n                // can end here\n                this.contiguousQuotesCount = 0;\n                this.insideStringStatus = StringOrMultilineStatus.NONE;\n                return {type: TokenType.MULTILINE_COMMENTS_OR_STRINGS}; // end the multiline triple single quotes, include all triple quotes at both sides\n            } else {\n                this.contiguousQuotesCount++;\n            }\n        } else { // got any other characters\n            this.contiguousQuotesCount = 0;\n            if (ch === '\\\\') {\n                this.previousIsEscape = !this.previousIsEscape; // flip it, since double escapes means the second one isn't an escape\n            } else {\n                this.previousIsEscape = false;\n            }\n        }\n        return null;\n    }\n\n    private handleTripleDoubleQuoteSituation(ch: string): {type: TokenType, singleChType?: TokenType} | null {\n        // wait until triple double quotes\n        if (ch === \"\\\"\" && !this.previousIsEscape) { // got single double but not escaped yet\n            this.previousIsEscape = false;\n            if (this.contiguousQuotesCount == 2) {\n                // can end here\n                this.contiguousQuotesCount = 0;\n                this.insideStringStatus = StringOrMultilineStatus.NONE;\n                return {type: TokenType.MULTILINE_COMMENTS_OR_STRINGS}; // end the multiline triple double quotes, include all triple quotes at both sides\n            } else {\n                this.contiguousQuotesCount++;\n            }\n        } else { // got any other characters\n            this.contiguousQuotesCount = 0;\n            if (ch === '\\\\') {\n                this.previousIsEscape = !this.previousIsEscape; // flip it, since double escapes means the second one isn't an escape\n            } else {\n                this.previousIsEscape = false;\n            }\n        }\n        return null;\n    }\n\n    private handleOtherSituation(ch: string): {tokenType: TokenType | null, isPlainCharacter: boolean} {\n        if (ch === \"{\" || ch === \"}\" || ch === \"[\" || ch === \"]\" || ch === \"(\" || ch === \")\") {\n            return {tokenType: TokenType.BRACES, isPlainCharacter: false};\n        } else if (ch === \" \" || ch === \"\\t\" || ch === \"\\n\") {\n            return {tokenType: TokenType.SPACINGS, isPlainCharacter: false};\n        } else if (ch === \":\") {\n            return {tokenType: TokenType.OTHERS, isPlainCharacter: false};\n        } else if (ch === \",\") {\n            return {tokenType: TokenType.COMMAS, isPlainCharacter: false};\n        } else if (ch === \"#\"){\n            this.insideSingleLineComments = true;\n            return {tokenType: null, isPlainCharacter: false};\n        } else if (ch === \"\\\"\") {\n            this.insideStringStatus = StringOrMultilineStatus.DOUBLE_QUOTES;\n            this.contiguousQuotesCount = 1;\n            return {tokenType: null, isPlainCharacter: false};\n        } else if (ch === \"\\'\") {\n            this.insideStringStatus = StringOrMultilineStatus.SINGLE_QUOTES;\n            this.contiguousQuotesCount = 1;\n            return {tokenType: null, isPlainCharacter: false};\n        }\n        return {tokenType: null, isPlainCharacter: true};\n    }\n}","import { StringExpressionMatcher } from \"../../matchers/StringExpressionMatcher\";\nimport { AbstractTokenizer } from \"../../parsing/AbstractTokenizer\";\nimport { TokenType } from \"../../parsing/ParsingTypes\";\n\nenum Status {\n    NONE = \"NONE\",\n    SINGLE_QUOTES = \"SINGLE_QUOTES\",\n    DOUBLE_QUOTES = \"DOUBLE_QUOTES\",\n    MULTILINE_BACKTICKS = \"MULTILINE_BACKTICKS\",\n    MULTILINE_COMMENTS = \"MULTILINE_COMMENTS\",\n    EQUALS = \"EQUALS\"\n}\n\nexport class TypeScriptTokenizer extends AbstractTokenizer {\n    private insideSingleLineComments: boolean;\n    private insideStringStatus: Status;\n    private previousIsEscape: boolean;\n    private stringMatcher: StringExpressionMatcher;\n\n    constructor() {\n        super();\n\n        this.insideStringStatus = Status.NONE;\n        this.insideSingleLineComments = false;\n        this.previousIsEscape = false;\n        this.stringMatcher = new StringExpressionMatcher({\n            COMMENT_START: \"//\",\n            MULTILINE_COMMENT_START: \"/*\",\n            MULTILINE_COMMENT_END: \"*/\"\n        });\n    }\n\n    protected matchNext(ch: string): {type: TokenType, singleChType?: TokenType, numSplitCharacters?: number} | null {\n        const matchedExpression: string | null = this.stringMatcher.next(ch);\n        if (matchedExpression !== null) {\n            this.stringMatcher.reset(); // ensure separated\n        }\n\n        if (this.insideSingleLineComments) {\n            // await newline\n            if (ch === \"\\n\") {\n                this.insideSingleLineComments = false;\n                return {type: TokenType.SINGLELINE_COMMENTS, singleChType: TokenType.SPACINGS};\n            }\n            return null;\n        } else if (this.insideStringStatus === Status.SINGLE_QUOTES) {\n            return this.handleSingleQuoteSituation(ch);\n        } else if (this.insideStringStatus === Status.DOUBLE_QUOTES) {\n            return this.handleDoubleQuoteSituation(ch);\n        } else if (this.insideStringStatus === Status.MULTILINE_BACKTICKS) {\n            return this.handleMultilineBackticksSituation(ch);\n        } else if (this.insideStringStatus === Status.MULTILINE_COMMENTS) {\n            return this.handleMultilineCommentsSituation(ch, matchedExpression);\n        } else if (this.insideStringStatus === Status.EQUALS) {\n            return this.handleEqualsSituation(ch, matchedExpression);\n        } else {\n            const situation = this.handleOtherSituation(ch, matchedExpression); // represents the token type of the single character, if applicable. else null.\n            if (situation.needsResetSplitChars === 0) {\n                // no need reset, continue the current token building\n                return null;\n            } else if (this.currentBufferLength() === situation.needsResetSplitChars) {\n                if (situation.tokenType === null) {\n                    // continue\n                    return null;\n                }\n                // detect a full token, and is equal to the current buffer length.\n                return {type: situation.tokenType};\n            } else {\n                // current buffer length strictly larger to the number of characters to be included into the current token. therefore we indicate splitting is needed\n                if (situation.tokenType === null) {\n                    // we still need to detect more characters to conclude the current token\n                    return {type: TokenType.OTHERS, singleChType: TokenType.CONTINUATION};\n                } else {\n                    // we don't have to detect more characters. conclude it.\n                    return {type: TokenType.OTHERS, singleChType: situation.tokenType};\n                }\n            }\n        }\n    }\n\n    protected matchEndCharacter(): TokenType {\n        if (this.insideSingleLineComments) {\n            return TokenType.SINGLELINE_COMMENTS;\n        } else if (this.insideStringStatus === Status.SINGLE_QUOTES || this.insideStringStatus === Status.DOUBLE_QUOTES) {\n            return TokenType.STRINGS;\n        } else if (this.insideStringStatus === Status.MULTILINE_BACKTICKS) {\n            return TokenType.MULTILINE_COMMENTS_OR_STRINGS;\n        } else if (this.insideStringStatus === Status.MULTILINE_COMMENTS) {\n            return TokenType.MULTILINE_COMMENTS_OR_STRINGS;\n        } else if (this.insideStringStatus === Status.EQUALS) {\n            return TokenType.OTHERS;\n        }\n        return TokenType.OTHERS;\n    }\n\n    protected onReset(): void {\n        this.insideStringStatus = Status.NONE;\n        this.insideSingleLineComments = false;\n        this.previousIsEscape = false;\n        this.stringMatcher.reset();\n    }\n\n    private handleSingleQuoteSituation(ch: string): {type: TokenType, singleChType?: TokenType} | null {\n        if (ch === \"\\'\" && !this.previousIsEscape) { // got single quotes but not escaped yet\n            this.previousIsEscape = false;\n            this.insideStringStatus = Status.NONE;\n            return {type: TokenType.STRINGS}; // end the single quotes since we've reached the end. include the full string with quotes at both sides\n        } else if (ch === \"\\n\"){\n            this.previousIsEscape = false;\n            this.insideStringStatus = Status.NONE;\n            return {type: TokenType.STRINGS, singleChType: TokenType.SPACINGS}; // actually incorrect syntax here, forgot closing quotes before newline.\n        } else { // got any other characters\n            if (ch === '\\\\') {\n                this.previousIsEscape = !this.previousIsEscape; // flip it, since double escapes means the second one isn't an escape\n            } else {\n                this.previousIsEscape = false;\n            }\n        }\n        return null;\n    }\n\n    private handleDoubleQuoteSituation(ch: string): {type: TokenType, singleChType?: TokenType} | null {\n        if (ch === \"\\\"\" && !this.previousIsEscape) { // got double quotes but not escaped yet\n            this.previousIsEscape = false;\n            this.insideStringStatus = Status.NONE;\n            return {type: TokenType.STRINGS}; // end the double quotes since we've reached the end. include the full string with quotes at both sides\n        } else if (ch === \"\\n\"){\n            this.previousIsEscape = false;\n            this.insideStringStatus = Status.NONE;\n            return {type: TokenType.STRINGS, singleChType: TokenType.SPACINGS}; // actually incorrect syntax here, forgot closing quotes before newline.\n        } else { // got any other characters\n            if (ch === '\\\\') {\n                this.previousIsEscape = !this.previousIsEscape; // flip it, since double escapes means the second one isn't an escape\n            } else {\n                this.previousIsEscape = false;\n            }\n        }\n        return null;\n    }\n\n    private handleMultilineBackticksSituation(ch: string): {type: TokenType, singleChType?: TokenType} | null {\n        if (ch === \"`\" && !this.previousIsEscape) { // got backticks but not escaped yet\n            this.previousIsEscape = false;\n            this.insideStringStatus = Status.NONE;\n            return {type: TokenType.MULTILINE_COMMENTS_OR_STRINGS}; // end the backticks since we've reached the end. include the full string with backticks at both sides\n        } else { // got any other characters\n            if (ch === '\\\\') {\n                this.previousIsEscape = !this.previousIsEscape; // flip it, since double escapes means the second one isn't an escape\n            } else {\n                this.previousIsEscape = false;\n            }\n        }\n        return null;\n    }\n\n    private handleMultilineCommentsSituation(ch: string, matchedExpression: string | null): {type: TokenType, singleChType?: TokenType} | null {\n        // no need to handle escapes since multiline comments doesn't have that\n        if (matchedExpression === \"MULTILINE_COMMENT_END\") { // got multiline comment end\n            this.insideStringStatus = Status.NONE;\n            return {type: TokenType.MULTILINE_COMMENTS_OR_STRINGS}; // end the multiline comments\n        }\n        return null;\n    }\n\n    private handleEqualsSituation(ch: string, matchedExpression: string | null): {type: TokenType, singleChType?: TokenType} | null {\n        this.insideStringStatus = Status.NONE;\n        if (ch === \">\") {\n            // conclude full\n            return {type: TokenType.OTHERS};\n        }\n        // conclude the equal sign along with another one\n        const action = this.handleOtherSituation(ch, matchedExpression);\n        const newChType: TokenType = action.tokenType === null ? TokenType.CONTINUATION : action.tokenType;\n        return {\n            type: TokenType.OTHERS,\n            singleChType: newChType\n        };\n    }\n\n    private handleOtherSituation(ch: string, matchedExpression: string | null): {tokenType: TokenType | null, needsResetSplitChars: number} {\n        if (ch === \"{\" || ch === \"}\" || ch === \"[\" || ch === \"]\" || ch === \"(\" || ch === \")\") {\n            return {tokenType: TokenType.BRACES, needsResetSplitChars: 1};\n        } else if (ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \";\") {\n            return {tokenType: TokenType.SPACINGS, needsResetSplitChars: 1};\n        } else if (ch === \",\") {\n            return {tokenType: TokenType.COMMAS, needsResetSplitChars: 1};\n        } else if (ch === \":\" || ch === \"<\" || ch === \">\") {\n            return {tokenType: TokenType.OTHERS, needsResetSplitChars: 1};\n        } else if (ch === \"=\") {\n            this.insideStringStatus = Status.EQUALS;\n            return {tokenType: null, needsResetSplitChars: 1};\n        } else if (ch === \"`\") {\n            this.insideStringStatus = Status.MULTILINE_BACKTICKS;\n            return {tokenType: null, needsResetSplitChars: 1};\n        } else if (ch === \"\\'\") {\n            this.insideStringStatus = Status.SINGLE_QUOTES;\n            return {tokenType: null, needsResetSplitChars: 1};\n        } else if (ch === \"\\\"\") {\n            this.insideStringStatus = Status.DOUBLE_QUOTES;\n            return {tokenType: null, needsResetSplitChars: 1};\n        } else if (matchedExpression === \"MULTILINE_COMMENT_START\"){\n            this.insideStringStatus = Status.MULTILINE_COMMENTS;\n            return {tokenType: null, needsResetSplitChars: 2};\n        } else if (matchedExpression === \"COMMENT_START\") {\n            this.insideSingleLineComments = true;\n            return {tokenType: null, needsResetSplitChars: 2};\n        }\n        return {tokenType: null, needsResetSplitChars: 0};\n    }\n}","import { Token, NonTerminal, Terminal, SymbolAdditionDirective, SymbolInfo, TokenType } from \"../../parsing/ParsingTypes\";\nimport { CodeParsingError } from \"../../CodeParsingError\";\nimport { Range } from \"../../utils\";\nimport { BracesMatcher } from \"../../matchers/BracesMatcher\";\nimport { AbstractParser } from \"../../parsing/AbstractParser\";\nimport { Argument, Attributes, Classes, Comments, FunctionDeclaration, Functions, References } from \"../../nodes\";\nimport { AbstractTokenizer } from \"../../parsing/AbstractTokenizer\";\nimport { PythonTokenizer } from \"./PythonTokenizer\";\n\nenum CodeBlockType {\n    SINGLE_LINE = \"SINGLE_LINE\",\n    MULTI_LINE = \"MULTI_LINE\"\n}\n\n/**\n * PythonParser class is responsible for parsing Python source code into a tree structure.\n * It detects top-level constructs such as classes, functions, comments, imports, and fillers.\n */\nexport class PythonParser extends AbstractParser {\n    // Indentation settings\n    private pythonCodeIndents: string = \"\";\n    private pythonIsTabs: boolean = false;\n    private bracesMatcher: BracesMatcher;\n\n    /**\n     * @returns The detected indentation.\n     */\n    public getDetectedIndentation(): string {\n        return this.pythonCodeIndents;\n    }\n\n    /**\n     * Initializes a new instance of the PythonParser class.\n     */\n    constructor() {\n        super();\n\n        this.parseType = NonTerminal.TOP_LEVEL;\n        this.continuousIndentAfterNewline = true;\n        this.mostRecentLineTokIndex = 0;\n        this.lastLineForEndCodeBlockIndex = 0;\n        this.indentationCount = 0;\n        this.parsingBlockInitiated = false;\n        this.prevTokenEndsWithBackslash = false;\n        this.detectionType = CodeBlockType.SINGLE_LINE;\n        this.detectionSymbol = Terminal.STATEMENTS_FILLER;\n        this.bracesMatcher = new BracesMatcher([\n            {opening: \"{\", closing: \"}\"},\n            {opening: \"[\", closing: \"]\"},\n            {opening: \"(\", closing: \")\"}\n        ]);\n        this.encounteredComments = false;\n        this.singleLineImmediatelyAfterComments = false;\n\n        this.stringStream = \"\";\n        this.tokenStream = [];\n        this.prevMultiline = false;\n        this.stopAcceptingStringStream = false;\n        this.classOrFuncBodyParseStart = -1;\n        this.globalDetectionStartIndex = -1;\n\n        this.functDetectingBody = false;\n        this.functColonIndex = -1;\n        this.functRightAfterDef = false;\n        this.functName = null;\n        this.functRightAfterArrow = false;\n        this.functType = null;\n\n        this.functBodyHasOthers = false;\n        this.functBodyHasPreviousContent = false;\n        this.functBodyImmediatelyHasMLComments = null;\n\n        this.functDeclStrBuffer = \"\";\n        this.functDeclStartParseIdx = -1;\n        this.functDeclParsing = false;\n\n        // Initialize various states\n        this.resetDetectionState(0, NonTerminal.TOP_LEVEL);\n    }\n\n    /**\n     * Prepares the PythonParser before parsing starts.\n     * Detects the indentation style used in the Python code,\n     * and creates the expression matchers relevant to the indentation.\n     */\n    protected preparse(codeLines: string[], tokens: Token[]): void {\n        /* Detect indentation */\n        const spaceIndentCounts: number[] = [];\n        let tabIndentCount = 0;\n\n        for (const line of codeLines) {\n            // Trim the line to check if it's not empty or only whitespace\n            if (line.trim().length === 0) {\n                continue; // Skip empty or whitespace-only lines\n            }\n\n            // Use regex to match leading whitespace\n            const match = line.match(/^([ \\t]+)/);\n            if (match) {\n                const indent = match[1];\n                const hasSpaces = indent.includes(' ');\n                const hasTabs = indent.includes('\\t');\n\n                if (hasSpaces && hasTabs) {\n                    throw new CodeParsingError(\"Python code cannot have mixed spaces and tabs for indentation!\");\n                }\n\n                if (hasSpaces) {\n                    const spaceCount = indent.length;\n                    spaceIndentCounts.push(spaceCount);\n                } else if (hasTabs) {\n                    tabIndentCount++;\n                }\n            }\n        }\n\n        // Check for mixed indentation\n        if (spaceIndentCounts.length > 0 && tabIndentCount > 0) {\n            throw new CodeParsingError(\"Python code cannot have mixed spaces and tabs for indentation!\");\n        }\n\n        // Check if there are any indented lines\n        if (spaceIndentCounts.length === 0 && tabIndentCount === 0) {\n            this.pythonIsTabs = false;\n            this.pythonCodeIndents = \"\"; // No indented lines, its possible for really small running scripts\n        }\n\n        if (tabIndentCount > 0) {\n            this.pythonIsTabs = true;\n            this.pythonCodeIndents = \"\\t\";\n            return;\n        }\n\n        // Define the possible indentation factors to test, starting from the largest\n        const possibleFactors = [12, 6, 4, 3, 2];\n\n        // Initialize indentStep as undefined; it will be set once a suitable factor is found\n        let indentStep: number | undefined;\n\n        // Iterate through each possible factor to find a suitable indent step\n        for (const factor of possibleFactors) {\n            // Skip if the factor is zero to avoid division by zero\n            if (factor === 0) continue;\n\n            // Count how many indentation counts are not multiples of the current factor\n            const invalidCount = spaceIndentCounts.filter(count => count % factor !== 0).length;\n\n            // Calculate the ratio of invalid indentation counts\n            const invalidRatio = invalidCount / spaceIndentCounts.length;\n\n            // Check if the invalid ratio is within the acceptable threshold (≤ 20%)\n            if (invalidRatio <= 0.2) {\n                indentStep = factor;\n                break; // Exit the loop once a suitable factor is found\n            }\n        }\n\n        // After testing all factors, ensure that an indent step was found\n        if (indentStep === undefined) {\n            throw new CodeParsingError(\"Unable to detect a consistent indentation step within the allowed threshold.\");\n        }\n\n        this.pythonCodeIndents = \" \".repeat(indentStep);\n        this.pythonIsTabs = false;\n    }\n\n    /**\n     * Returns whether comments for functions are placed before or after the function.\n     * For Python, comments are typically placed after the function.\n     */\n    protected isCommentBeforeFunction(): boolean {\n        return false;\n    }\n\n    /**\n     * We use PythonTokenizer\n     * @returns A new PythonTokenizer\n     */\n    protected preparseGetTokenizer(): AbstractTokenizer {\n        return new PythonTokenizer();\n    }\n\n\n    protected createArgumentNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): Argument {\n        return new Argument(range, nodeCreationInformation!.argumentName!, nodeCreationInformation!.argumentType);\n    }\n    protected createAttributesNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): Attributes {\n        return new Attributes(range, nodeCreationInformation!.attributeName!, nodeCreationInformation!.attributeType);\n    }\n    protected createCommentsNode(range: Range, isMultiLine: boolean, nodeCreationInformation: Record<string, any> | undefined): Comments {\n        return new Comments(range, isMultiLine, nodeCreationInformation!.commentContents!);\n    }\n    protected createReferencesNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): References {\n        return new References(range, nodeCreationInformation!.referenceText!, nodeCreationInformation!.refRelativePath);\n    }\n    protected createClassesNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): Classes {\n        // better to include the inner range, so that it is possible to extract more precisely the minimal \"keywords\" used to match the class\n        const node = new Classes(range, nodeCreationInformation!.classType, nodeCreationInformation!.classDefinitionText!);\n        node.overrideInnerRange(nodeCreationInformation!.classInnerRange!);\n        return node;\n    }\n    protected createFunctionsNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): Functions {\n        // better to include the inner range, so that it is possible to extract more precisely the minimal \"keywords\" used to match the function\n        const node = new Functions(range, nodeCreationInformation!.functionDefinitionText!);\n        node.overrideInnerRange(nodeCreationInformation!.funcInnerRange!);\n        return node;\n    }\n    protected createFunctionDeclarationNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): FunctionDeclaration {\n        return new FunctionDeclaration(range, nodeCreationInformation!.functionName!, nodeCreationInformation!.functionReturnType);\n    }\n\n    // global indicator states\n    private parseType: NonTerminal;\n    private globalDetectionStartIndex: number;\n\n    // manipulated by updateCodeBlocksBracesAndSpacingsState\n    private continuousIndentAfterNewline: boolean;\n    private mostRecentLineTokIndex: number;\n    private indentationCount: number;    \n    private prevTokenEndsWithBackslash: boolean;\n\n    // manipulated by detectCodeBlocks\n    private parsingBlockInitiated: boolean;\n    private lastLineForEndCodeBlockIndex: number;\n    private encounteredComments: boolean;\n    private singleLineImmediatelyAfterComments: boolean;\n\n    // manipulated by updateCodeBlocksContentsParseState. the variables with * means that its also resetted by detectCodeBlocks\n    private detectionType: CodeBlockType; // *\n    private detectionSymbol: NonTerminal | Terminal; // *\n\n    protected resetDetectionState(startTokIndex: number, parsingNonTerminal: NonTerminal): void {\n        this.globalDetectionStartIndex = startTokIndex;\n        this.parseType = parsingNonTerminal;\n        this.bracesMatcher.reset();\n\n        if (parsingNonTerminal === NonTerminal.TOP_LEVEL) {\n            this.continuousIndentAfterNewline = true; // at the top level, tokens in the start of the first line is a \"continuous\" after a new line\n            this.mostRecentLineTokIndex = -1;\n            this.indentationCount = 0;\n            this.prevTokenEndsWithBackslash = false;\n\n            this.parsingBlockInitiated = false;\n            this.lastLineForEndCodeBlockIndex = -1;\n            this.encounteredComments = false;\n            this.singleLineImmediatelyAfterComments = false;\n\n            this.detectionType = CodeBlockType.SINGLE_LINE;\n            this.detectionSymbol = Terminal.STATEMENTS_FILLER;\n        } else if (parsingNonTerminal === NonTerminal.CLASSES) {\n            this.continuousIndentAfterNewline = false; // need to reset the trigger\n            this.mostRecentLineTokIndex = -1;\n            this.indentationCount = 0;\n            this.prevTokenEndsWithBackslash = false;\n\n            this.parsingBlockInitiated = false;\n            this.lastLineForEndCodeBlockIndex = -1;\n            this.encounteredComments = false;\n            this.singleLineImmediatelyAfterComments = false;\n\n            this.detectionType = CodeBlockType.SINGLE_LINE;\n            this.detectionSymbol = Terminal.STATEMENTS_FILLER;\n        } else if (parsingNonTerminal === NonTerminal.FUNCTIONS) {\n            this.functDetectingBody = false;\n            this.functColonIndex = -1;\n            this.functRightAfterDef = false;\n            this.functName = null;\n            this.functRightAfterArrow = false;\n            this.functType = null;\n        } else if (parsingNonTerminal === NonTerminal.FUNCTION_BODY) {\n            this.continuousIndentAfterNewline = false;\n            this.mostRecentLineTokIndex = -1;\n            this.indentationCount = 0;\n            this.prevTokenEndsWithBackslash = false;\n\n            this.functBodyHasOthers = false;\n            this.functBodyHasPreviousContent = false;\n            this.functBodyImmediatelyHasMLComments = null;\n        } else if (parsingNonTerminal === NonTerminal.FUNCTION_DECLARATION) {\n            this.continuousIndentAfterNewline = false;\n            this.mostRecentLineTokIndex = -1;\n            this.indentationCount = 0;\n            this.prevTokenEndsWithBackslash = false;\n\n            this.functDeclStrBuffer = \"\";\n            this.functDeclStartParseIdx = -1;\n            this.functDeclParsing = false;\n        }\n    }\n\n    protected detectTopLevelSymbol(state: (Terminal | NonTerminal)[], token: Token | null, currentTokIndex: number, depth: number): SymbolAdditionDirective | null {\n        return this.detectCodeBlocks(token, depth, currentTokIndex);\n    }\n\n    protected detectClassesSymbol(state: (Terminal | NonTerminal)[], token: Token | null, currentTokIndex: number, depth: number): SymbolAdditionDirective | null {\n        return this.detectCodeBlocks(token, depth, currentTokIndex);\n    }\n\n    private functDetectingBody: boolean;\n    private functColonIndex: number;\n    private functRightAfterDef: boolean;\n    private functName: string | null;\n    private functRightAfterArrow: boolean;\n    private functType: string | null;\n    protected detectFunctionsSymbol(state: (Terminal | NonTerminal)[], token: Token | null, currentTokIndex: number, depth: number): SymbolAdditionDirective | null {\n        // simply detect left to right, and then look at a colon\n        if (this.functDetectingBody) {\n            // we add all until the end. function body itself doesn't have a node class, so there is no need for node creation info\n            // the parse range will simply be the full range after the colon\n            if (token === null)\n                return {symbol: { symbolType: NonTerminal.FUNCTION_BODY }};\n        } else {\n            if (token === null) {\n                throw new CodeParsingError(\"Expected function to be separated by a colon!\");\n            }\n\n            if (this.bracesMatcher.currentDepth() === 0 && token.stringContents.indexOf(\":\") !== -1) {\n                // parse range simply does not include the start\n                this.functColonIndex = currentTokIndex;\n                this.functDetectingBody = true;\n\n                if (this.functName === null) {\n                    throw new CodeParsingError(\"Invalid syntax! Missing function name between def and colon!\");\n                }\n                if (this.functType !== null) {\n                    this.functType = this.functType.trim();\n                }\n\n                // sub parse range does not include the colon. function type can be null since its optional\n                return {symbol: {\n                    symbolType: NonTerminal.FUNCTION_DECLARATION,\n                    parseRange: {startTok: this.globalDetectionStartIndex, endTok: this.functColonIndex},\n                    nodeCreationInformation: {functionName: this.functName.trim(), functionReturnType: this.functType}\n                }};\n            }\n            if (this.functRightAfterDef && token.tokenType === TokenType.OTHERS) { // first token must be def, second is funct name\n                this.functRightAfterDef = false;\n                this.functName = token!.stringContents;\n            } else if (this.functRightAfterDef && token.tokenType !== TokenType.SPACINGS) {\n                this.functRightAfterDef = false;\n            } else if (currentTokIndex === this.globalDetectionStartIndex) { // must be def\n                this.functRightAfterDef = true;\n            }\n            if (this.functRightAfterArrow && token.tokenType === TokenType.OTHERS) { // right after the arrow ->\n                this.functRightAfterArrow = false;\n                this.functType = token.stringContents;\n            } else if (this.functRightAfterArrow && token.tokenType !== TokenType.SPACINGS) {\n                this.functRightAfterArrow = false;\n            } else if (token.stringContents === \"->\" && this.bracesMatcher.currentDepth() === 0) {\n                this.functRightAfterArrow = true;\n            }\n\n            if (token.tokenType === TokenType.BRACES) {\n                try {\n                    this.bracesMatcher.next(token.stringContents);\n                } catch (e: any) {\n                    if (e instanceof Error) {\n                        throw new CodeParsingError(\"Error during brace matching! \" + e.message);\n                    }\n                    throw e;\n                }\n            }\n        }\n        return null;\n    }\n\n    private functBodyHasOthers: boolean;\n    private functBodyHasPreviousContent: boolean;\n    private functBodyImmediatelyHasMLComments: string | null;\n    protected detectFunctionBodySymbol(state: (Terminal | NonTerminal)[], token: Token | null, currentTokIndex: number, depth: number): SymbolAdditionDirective | null {\n        // simply parse the comments and multiline comments, without caring about the indentation\n        if (token === null) {\n            if (this.functBodyImmediatelyHasMLComments !== null) {\n                if (this.functBodyHasPreviousContent) {\n                    return {\n                        symbol: {symbolType: this.functBodyHasOthers ? Terminal.STATEMENTS_FILLER: Terminal.FILLER},\n                        secondSymbol: {symbolType: Terminal.COMMENT_MULTILINE, nodeCreationInformation: {commentContents: this.functBodyImmediatelyHasMLComments}},\n                        secondSymbolLen: 1\n                    };\n                } else {\n                    return {\n                        symbol: {symbolType: Terminal.COMMENT_MULTILINE, nodeCreationInformation: {commentContents: this.functBodyImmediatelyHasMLComments}}\n                    };\n                }\n            } else {\n                if (this.functBodyHasPreviousContent) {\n                    return {symbol: {symbolType: this.functBodyHasOthers ? Terminal.STATEMENTS_FILLER: Terminal.FILLER}};\n                }\n            }\n            return null;\n        }\n\n        let retDirective: SymbolAdditionDirective | null = null;\n        if (token.tokenType === TokenType.SINGLELINE_COMMENTS) {\n            if (this.functBodyHasPreviousContent) {\n                retDirective = {\n                    symbol: {symbolType: this.functBodyHasOthers ? Terminal.STATEMENTS_FILLER: Terminal.FILLER},\n                    secondSymbol: {symbolType: Terminal.COMMENT_SINGLELINE, nodeCreationInformation: {commentContents: token.stringContents.substring(1, token.stringContents.length)}}\n                }\n            } else {\n                retDirective = {symbol: {symbolType: Terminal.COMMENT_SINGLELINE, nodeCreationInformation: {commentContents: token.stringContents.substring(1, token.stringContents.length)}}};\n            }\n\n            // reset\n            this.functBodyHasOthers = false;\n            this.functBodyHasPreviousContent = false;\n        } else if (token.tokenType === TokenType.MULTILINE_COMMENTS_OR_STRINGS && this.continuousIndentAfterNewline) {\n            this.functBodyImmediatelyHasMLComments = token.stringContents.substring(3, token.stringContents.length - 3);\n        } else if ((this.functBodyImmediatelyHasMLComments !== null) && token.stringContents === \"\\n\") {\n            if (this.functBodyHasPreviousContent) {\n                retDirective = {\n                    symbol: {symbolType: this.functBodyHasOthers ? Terminal.STATEMENTS_FILLER: Terminal.FILLER},\n                    secondSymbol: {symbolType: Terminal.COMMENT_MULTILINE, nodeCreationInformation: {commentContents: this.functBodyImmediatelyHasMLComments}},\n                    secondSymbolLen: 1,\n                    firstTwoSymbolsEndBufferLen: 1\n                }\n            } else {\n                retDirective = {\n                    symbol: {symbolType: Terminal.COMMENT_MULTILINE, nodeCreationInformation: {commentContents: this.functBodyImmediatelyHasMLComments}},\n                    secondSymbolLen: 1\n                };\n            }\n\n             // reset\n             this.functBodyHasOthers = false;\n             this.functBodyHasPreviousContent = false;\n             this.functBodyImmediatelyHasMLComments = null;\n        } else {\n            this.functBodyHasPreviousContent = true;\n            this.functBodyImmediatelyHasMLComments = null;\n            if (token.tokenType !== TokenType.SPACINGS) {\n                this.functBodyHasOthers = true;\n            }\n        }\n\n        this.updateCodeBlocksBracesAndSpacingsState(token, currentTokIndex);\n        return retDirective;\n    }\n\n\n    private functDeclStrBuffer: string;\n    private functDeclStartParseIdx: number;\n    private functDeclParsing: boolean;\n    protected detectFunctionDeclarationSymbol(state: (Terminal | NonTerminal)[], token: Token | null, currentTokIndex: number, depth: number): SymbolAdditionDirective | null {\n        // simply separate by commas\n        if (token === null) {\n            return {symbol: {symbolType: Terminal.FILLER}};\n        }\n\n        let retDirective: SymbolAdditionDirective | null = null;\n        if (this.functDeclParsing) {\n            if (token.tokenType !== TokenType.COMMAS) {\n                // when === 1 and === \")\", this means the function declaration is closing. don't add that.\n                if (this.bracesMatcher.currentDepth() > 1 || token.stringContents !== \")\") {\n                    this.functDeclStrBuffer += token.stringContents;\n                }\n            } else if (this.bracesMatcher.currentDepth() > 1) {\n                this.functDeclStrBuffer += token.stringContents; // comma inside braces, we still add\n            } else if (this.bracesMatcher.currentDepth() === 1) {\n                let argument: string = this.trimReplaceString(this.functDeclStrBuffer);\n                if (argument.length === 0) {\n                    this.functDeclStrBuffer = \"\";\n                } else {\n                    // conclude, since comma reached, with something\n                    let idx: number = argument.indexOf(\"=\");\n                    if (idx !== -1) {\n                        argument = argument.substring(0, idx).trim();\n                    }\n                    idx = argument.indexOf(\":\");\n                    let argumentName: string;\n                    let argumentType: string | null = null;\n                    if (idx > 0 && idx < argument.length - 1) {\n                        argumentName = argument.substring(0, idx).trim();\n                        argumentType = argument.substring(idx + 1, argument.length).trim();\n                    } else {\n                        argumentName = argument;\n                    }\n\n                    retDirective = {\n                        symbol: {symbolType: Terminal.FILLER},\n                        secondSymbol: {symbolType: Terminal.ARGUMENT, nodeCreationInformation: {argumentName: argumentName, argumentType: argumentType}},\n                        secondSymbolLen: currentTokIndex - this.functDeclStartParseIdx - 1,\n                        firstTwoSymbolsEndBufferLen: 1\n                    };\n                    this.functDeclStartParseIdx = currentTokIndex;\n                    this.functDeclStrBuffer = \"\";\n                }\n            }\n        }\n        this.updateCodeBlocksBracesAndSpacingsState(token, currentTokIndex);\n        if (this.functDeclParsing && this.bracesMatcher.currentDepth() === 0) {\n            this.functDeclParsing = false;\n\n            // conclude, since bracket ended\n            let argument: string = this.trimReplaceString(this.functDeclStrBuffer);\n            if (argument.length === 0) {\n                this.functDeclStrBuffer = \"\";\n            } else {\n                // conclude, since close brackets reached, with something\n                let idx: number = argument.indexOf(\"=\");\n                if (idx !== -1) {\n                    argument = argument.substring(0, idx).trim();\n                }\n                idx = argument.indexOf(\":\");\n                let argumentName: string;\n                let argumentType: string | null = null;\n                if (idx > 0 && idx < argument.length - 1) {\n                    argumentName = argument.substring(0, idx).trim();\n                    argumentType = argument.substring(idx + 1, argument.length).trim();\n                } else {\n                    argumentName = argument;\n                }\n\n                retDirective = {\n                    symbol: {symbolType: Terminal.FILLER},\n                    secondSymbol: {symbolType: Terminal.ARGUMENT, nodeCreationInformation: {argumentName: argumentName, argumentType: argumentType}},\n                    secondSymbolLen: currentTokIndex - this.functDeclStartParseIdx - 1,\n                    firstTwoSymbolsEndBufferLen: 1\n                };\n                this.functDeclStartParseIdx = currentTokIndex;\n                this.functDeclStrBuffer = \"\";\n            }\n        } else if (this.bracesMatcher.currentDepth() > 0 && this.functDeclStartParseIdx === -1) {\n            this.functDeclStartParseIdx = currentTokIndex;\n            this.functDeclParsing = true;\n        }\n\n        return retDirective;\n    }\n\n    private detectCodeBlocks(token: Token | null, depth: number, currentTokIndex: number): SymbolAdditionDirective | null {\n        if (token === null) {\n            // try to conclude the tokens\n            if (this.parsingBlockInitiated) {\n                // try to conclude. note that all single lines are concluded since a \"\\n\" will be added at the end. so this must be multiline, and the end tok is lastLineForEndCodeBlockIndex\n                const symbol = this.concludeCodeBlock(currentTokIndex);\n                const length: number = currentTokIndex - this.lastLineForEndCodeBlockIndex;\n                if (symbol.symbolType === Terminal.FILLER || symbol.symbolType === Terminal.STATEMENTS_FILLER ||\n                    length === 0\n                ) {\n                    return {symbol: symbol};\n                } else {\n                    return {symbol: symbol,\n                        secondSymbol: {symbolType: Terminal.FILLER},\n                        secondSymbolLen: length\n                    };\n                }\n            } else {\n                if (this.mostRecentLineTokIndex !== -1 || this.indentationCount > 0) {\n                    // conclude the filler symbol, but do not include the current token into the filler (has 1 element)\n                    return {symbol: {symbolType: Terminal.FILLER}};\n                }\n            }\n            return null;\n        }\n\n        const indentationExpected: number = depth * (this.pythonIsTabs ? 1 : this.pythonCodeIndents.length);\n        let retDirective: SymbolAdditionDirective | null = null;\n        if (this.parsingBlockInitiated) {\n            let hasConclusion: boolean = false;\n\n            // try to await for the stopping signal\n            if (this.detectionType === CodeBlockType.SINGLE_LINE) {\n                if (token.stringContents === \"\\n\" && this.bracesMatcher.currentDepth() === 0 && !this.prevTokenEndsWithBackslash) {\n                    // stop single line when we meet a newline not enclosed in braces\n                    this.parsingBlockInitiated = false;\n\n                    // if its immediately after a comment (due to being statements filler), there are no contents (tokens) in the buffer (except the current \"\\n\").\n                    if (!this.singleLineImmediatelyAfterComments) { // so we need to check\n                        // the symbol info will be the first symbol, while the \"second\" one (starting with the \"\\n\" token) is not concluded yet\n                        const symbolInfo: SymbolInfo = this.concludeCodeBlock(-1);\n                        retDirective = {\n                            symbol: symbolInfo,\n                            secondSymbolLen: 1\n                        };\n                    }\n\n                    // mark that conclusion has been done\n                    hasConclusion = true;\n                }\n\n                this.singleLineImmediatelyAfterComments = false; // flag false. if its statements filler and we have to handle it, it will be handled below\n            } else { // multi line\n                if (this.bracesMatcher.currentDepth() === 0) { // not in any braces\n\n                    // check whether we arrive at a new code block (closed the indentation)\n                    if (this.continuousIndentAfterNewline && token.tokenType !== TokenType.SPACINGS &&\n                            this.indentationCount <= indentationExpected && token.tokenType !== TokenType.SINGLELINE_COMMENTS) {\n                        // stop multiline if we encounter a new line that is not enclosed in braces, and the indentation goes back to the \"main expected\" indentation, and its not a single line comment\n\n                        // there are two symbols, and a single (the most recent) token that remains in the buffer. the first symbol is the multi line code block, while the second is the filler between the two symbols\n                        const symbolInfo: SymbolInfo = this.concludeCodeBlock(-1);\n                        retDirective = {\n                            symbol: symbolInfo,\n                            secondSymbol: {symbolType: Terminal.FILLER},\n                            secondSymbolLen: currentTokIndex - this.lastLineForEndCodeBlockIndex,\n                            firstTwoSymbolsEndBufferLen: 1\n                        };\n\n                        // reset new parsing, and by default single line\n                        this.parsingBlockInitiated = true;\n                        this.detectionType = CodeBlockType.SINGLE_LINE;\n                        this.detectionSymbol = Terminal.STATEMENTS_FILLER;\n                        this.encounteredComments = false;\n                        this.singleLineImmediatelyAfterComments = false;\n\n                        // update the parse state to reset and detect the new code block\n                        this.updateCodeBlocksContentsParseState(token, true, currentTokIndex, indentationExpected);\n\n                        // mark that conclusion has been done\n                        hasConclusion = true;\n                    } else if (token.stringContents === \"\\n\" && !this.prevTokenEndsWithBackslash && !this.continuousIndentAfterNewline) { // check whether we arrived at potential end of multiline block\n                        // checks that the line ends, and the line is non-empty\n                        this.lastLineForEndCodeBlockIndex = currentTokIndex;\n                    }\n                }\n            }\n\n            if (token.tokenType === TokenType.SINGLELINE_COMMENTS && this.detectionSymbol === Terminal.STATEMENTS_FILLER) {\n                // if we encounter a singleline comment, and its wrapped around (previously) with statements fillers, then we add it\n\n                // conclude the statements filler previous symbol, along with the current singleline comment symbol with one token\n                retDirective = {\n                    symbol: {symbolType: Terminal.STATEMENTS_FILLER},\n                    secondSymbol: {symbolType: Terminal.COMMENT_SINGLELINE, nodeCreationInformation: {commentContents: token.stringContents.substring(1, token.stringContents.length)}}\n                };\n\n                // lock the state to only allow fillers and statements fillers subsequently, until the code block is completed\n                this.encounteredComments = true;\n                this.singleLineImmediatelyAfterComments = true; // there will be a \\n immediately afterwards. handle in this.detectionType === CodeBlockType.SINGLE_LINE\n            } else if (!(this.encounteredComments || hasConclusion)) {\n                // continue resolving the states as normal only if no comments have been encountered and no conclusions have been made\n                this.updateCodeBlocksContentsParseState(token, false, currentTokIndex, indentationExpected);\n            }\n        } else {\n            // try to await for the initiation signal\n            if (this.continuousIndentAfterNewline && token.tokenType !== TokenType.SPACINGS) {\n                if (token.tokenType === TokenType.SINGLELINE_COMMENTS) {\n                    // second symbol has length 1 in tokens. see if there are filler tokens previously\n                    if (this.mostRecentLineTokIndex !== -1 || this.indentationCount > 0) {\n                        // conclude both the filler and the contents\n                        retDirective = {\n                            symbol: {symbolType: Terminal.FILLER},\n                            secondSymbol: {symbolType: Terminal.COMMENT_SINGLELINE, nodeCreationInformation: {commentContents: token.stringContents.substring(1, token.stringContents.length)}}\n                        };\n                    } else {\n                        // conclude only the single symbol comments\n                        retDirective = {\n                            symbol: {symbolType: Terminal.COMMENT_SINGLELINE, nodeCreationInformation: {commentContents: token.stringContents.substring(1, token.stringContents.length)}}\n                        };\n                    }\n                } else {\n                    this.parsingBlockInitiated = true;\n                    this.detectionType = CodeBlockType.SINGLE_LINE;\n                    this.detectionSymbol = Terminal.STATEMENTS_FILLER;\n                    this.encounteredComments = false;\n                    this.singleLineImmediatelyAfterComments = false;\n\n                    if (this.mostRecentLineTokIndex !== -1 || this.indentationCount > 0) {\n                        // conclude the filler symbol, but do not include the current token into the filler (has 1 element)\n                        retDirective = {\n                            symbol: {symbolType: Terminal.FILLER},\n                            secondSymbolLen: 1\n                        };\n                    } // else we don't have to conclude anything, and this is the start of parsing of a new token\n                    this.updateCodeBlocksContentsParseState(token, true, currentTokIndex, indentationExpected);\n                }\n            }\n        }\n\n        // update the state(s) of braces and spacings, with the current newly added token\n        this.updateCodeBlocksBracesAndSpacingsState(token, currentTokIndex);\n        return retDirective;\n    }\n\n    private tokenStream: Token[];\n    private stringStream: string;\n    private stopAcceptingStringStream: boolean;\n    private prevMultiline: boolean;\n    private classOrFuncBodyParseStart: number;\n    private updateCodeBlocksContentsParseState(token: Token, needsReset: boolean, currentTokIndex: number, indentationExpected: number) {\n        if (needsReset) {\n            this.tokenStream = [];\n            this.stringStream = \"\";\n            this.prevMultiline = false;\n            this.stopAcceptingStringStream = false;\n            this.classOrFuncBodyParseStart = -1;\n        }\n\n        if (this.parseType === NonTerminal.TOP_LEVEL) {\n            // only have imports, multiline comments, functions and classes\n            if (this.stringStream.length === 0) {\n                if (indentationExpected === this.indentationCount) { // check indentation correct level\n                    if (token.stringContents === \"from\" || token.stringContents === \"import\" || token.stringContents === \"from\\\\\" || token.stringContents === \"import\\\\\") {\n                        this.detectionSymbol = Terminal.REFERENCES;\n                    } else if (token.stringContents === \"def\" || token.stringContents === \"def\\\\\") {\n                        this.detectionType = CodeBlockType.MULTI_LINE;\n                        this.detectionSymbol = NonTerminal.FUNCTIONS;\n                    } else if (token.stringContents === \"class\" || token.stringContents === \"class\\\\\") {\n                        this.detectionType = CodeBlockType.MULTI_LINE;\n                        this.detectionSymbol = NonTerminal.CLASSES;\n                    } else if (token.tokenType === TokenType.MULTILINE_COMMENTS_OR_STRINGS) {\n                        this.detectionSymbol = Terminal.COMMENT_MULTILINE;\n                    }\n                }\n            } else {\n                if (this.detectionSymbol === Terminal.COMMENT_MULTILINE && token.tokenType !== TokenType.SPACINGS) {\n                    // there is something after the multiline, which is not expected. we therefore demote it\n                    this.detectionSymbol = Terminal.STATEMENTS_FILLER;\n                }\n\n                if (this.detectionSymbol === NonTerminal.FUNCTIONS) {\n                    // stop recording the string stream when we've reached the colon, and only look at the first\n                    if (!this.stopAcceptingStringStream && this.bracesMatcher.currentDepth() === 0 && token.stringContents.indexOf(\":\") !== -1) {\n                        this.stopAcceptingStringStream = true;\n                        this.classOrFuncBodyParseStart = currentTokIndex + 1;\n                    }\n                }\n\n                if (this.detectionSymbol === NonTerminal.CLASSES) {\n                    // similar, but also be aware of the class body\n                    if (!this.stopAcceptingStringStream && this.bracesMatcher.currentDepth() === 0 && token.stringContents.indexOf(\":\") !== -1) {\n                        this.stopAcceptingStringStream = true;\n                        this.classOrFuncBodyParseStart = currentTokIndex + 1; // start parsing from the next token inclusive\n                    }\n                }\n            }\n\n            // add things to the token stream and string stream\n            if (token.tokenType !== TokenType.SPACINGS) {\n                this.tokenStream.push(token);\n            }\n            if (!this.stopAcceptingStringStream)\n                this.stringStream += token.stringContents;\n        } else if (this.parseType === NonTerminal.CLASSES) {\n            // only have multiline comments, functions and attributes\n            if (this.stringStream.length === 0) {\n                if (indentationExpected === this.indentationCount) { // check indentation correct level\n                    if (token.stringContents === \"def\" || token.stringContents === \"def\\\\\") {\n                        this.detectionType = CodeBlockType.MULTI_LINE;\n                        this.detectionSymbol = NonTerminal.FUNCTIONS;\n                    } else if (token.tokenType === TokenType.MULTILINE_COMMENTS_OR_STRINGS) {\n                        this.detectionSymbol = Terminal.COMMENT_MULTILINE;\n                        this.prevMultiline = true;\n                    }\n                }\n            } else {\n                if (this.detectionSymbol === Terminal.COMMENT_MULTILINE && token.tokenType !== TokenType.SPACINGS) {\n                    // there is something after the multiline, which is not expected. we therefore demote it\n                    this.detectionSymbol = Terminal.STATEMENTS_FILLER;\n                }\n\n                if (this.detectionSymbol === NonTerminal.FUNCTIONS) {\n                    // stop recording the string stream when we've reached the colon\n                    if (!this.stopAcceptingStringStream && this.bracesMatcher.currentDepth() === 0 && token.stringContents.indexOf(\":\") !== -1) {\n                        this.stopAcceptingStringStream = true;\n                        this.classOrFuncBodyParseStart = currentTokIndex + 1;\n                    }\n                }\n            }\n\n            // upgrade to attributes if previously there weren't a multiline string, and its a filler, and there is a colon in the middle\n            if ((!this.prevMultiline) && this.detectionSymbol === Terminal.STATEMENTS_FILLER && this.bracesMatcher.currentDepth() === 0 &&\n                indentationExpected === this.indentationCount &&\n                ((this.stringStream.length > 0 && token.stringContents.lastIndexOf(\":\") !== -1) || token.stringContents.lastIndexOf(\":\") > 0)) {\n                this.detectionSymbol = Terminal.ATTRIBUTES;\n            }\n\n            // add things to the token stream and string stream\n            if (token.tokenType !== TokenType.SPACINGS) {\n                this.tokenStream.push(token);\n            }\n            if (!this.stopAcceptingStringStream)\n                this.stringStream += token.stringContents;\n        } else {\n            throw Error(\"Not supported!\");\n        }\n    }\n\n    private concludeCodeBlock(reachedGlobalEndIndex: number): SymbolInfo {\n        if (reachedGlobalEndIndex !== -1) {\n            /* note that this is called only if its multiline or not top level,\n             * since top level single lines must be concluded, due to the extra \\n\n             * at the end of the code string (a \\n is always appended at the end).\n            */\n            if (!this.prevTokenEndsWithBackslash && !this.continuousIndentAfterNewline) {\n                // update the end only if there is something in the line\n                this.lastLineForEndCodeBlockIndex = reachedGlobalEndIndex;\n            }\n        }\n\n        if (this.parseType === NonTerminal.TOP_LEVEL) {\n            if (this.detectionSymbol === Terminal.STATEMENTS_FILLER) {\n                return {symbolType: Terminal.STATEMENTS_FILLER};\n            } else if (this.detectionSymbol === Terminal.REFERENCES) {\n                const referenceText: string = this.trimReplaceString(this.stringStream);\n                let referenceRelativePath: string | null = null;\n                if (this.tokenStream.length >= 4 && (this.tokenStream[0].stringContents === \"from\" || this.tokenStream[0].stringContents === \"from\\\\\")\n                    && (this.tokenStream[2].stringContents === \"import\" || this.tokenStream[2].stringContents === \"import\\\\\")) {\n                    // try to resolve the import\n                    const importContents: string = this.tokenStream[1].stringContents;\n                    if (importContents.length > 0) {\n                        if (importContents.charAt(0) === \".\") {\n                            // relative import (local file)\n                            const lcPath = importContents.substring(1, importContents.length);\n                            if (lcPath.length === 0) {\n                                referenceRelativePath = \"local-file://\";\n                            } else {\n                                let count: number = 0;\n                                for (let i = 0; i < lcPath.length; i++) {\n                                    if (lcPath.charAt(i) === \".\") {\n                                        count++;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                                referenceRelativePath = \"local-file://\" + \"../\".repeat(count) + lcPath.substring(count, lcPath.length).replace(/\\./g, \"/\");\n                            }\n                        } else {\n                            // environment import\n                            referenceRelativePath = \"environment://\" + importContents.replace(/\\./g, \"/\");\n                        }\n                    }\n                } else if (this.tokenStream.length >= 2 && (this.tokenStream[0].stringContents === \"import\" || this.tokenStream[0].stringContents === \"import\\\\\")) {\n                    // try to resolve the import\n                    const importContents: string = this.tokenStream[1].stringContents;\n                    if (importContents.length > 0) {\n                        referenceRelativePath = \"environment://\" + importContents.replace(/\\./g, \"/\");\n                    }\n                }\n                return {symbolType: Terminal.REFERENCES, nodeCreationInformation: {\n                    referenceText: referenceText,\n                    refRelativePath: referenceRelativePath\n                }};\n            } else if (this.detectionSymbol === Terminal.COMMENT_MULTILINE) {\n                // multiline comments can only have spaces before the \"\\n\", and the space\n                const trimmed: string = this.trimReplaceString(this.stringStream);\n                return {symbolType: Terminal.COMMENT_MULTILINE, nodeCreationInformation: {\n                    commentContents: trimmed.substring(3, trimmed.length - 3)\n                }};\n            } else if (this.detectionSymbol === NonTerminal.FUNCTIONS) {\n                if (!this.stopAcceptingStringStream) {\n                    // didn't detect the colon, we therefore need to reject it\n                    return {symbolType: Terminal.STATEMENTS_FILLER};\n                }\n\n                // use the same parse range as the range of the functions\n                const functionDefnText: string = this.trimReplaceString(this.stringStream);\n                return {symbolType: NonTerminal.FUNCTIONS, nodeCreationInformation: {\n                    functionDefinitionText: functionDefnText,\n                    funcInnerRange: this.getRange(this.getTokenChRange(this.classOrFuncBodyParseStart).start, this.getTokenChRange(this.lastLineForEndCodeBlockIndex).start)\n                }};\n            } else if (this.detectionSymbol === NonTerminal.CLASSES) {\n                // a different parse range, and also extract the defn text.\n                if (this.classOrFuncBodyParseStart === -1 || this.classOrFuncBodyParseStart >= this.lastLineForEndCodeBlockIndex) {\n                    // didn't detect the colon. we therefore need to reject it\n                    return {symbolType: Terminal.STATEMENTS_FILLER};\n                }\n                const classDefnText: string = this.trimReplaceString(this.stringStream);\n                return {symbolType: NonTerminal.CLASSES, parseRange: {startTok: this.classOrFuncBodyParseStart, endTok: this.lastLineForEndCodeBlockIndex}, nodeCreationInformation: {\n                    classType: null, classDefinitionText: classDefnText,\n                    classInnerRange: this.getRange(this.getTokenChRange(this.classOrFuncBodyParseStart).start, this.getTokenChRange(this.lastLineForEndCodeBlockIndex).start)\n                }};\n            } else {\n                throw Error(\"Not supported!\");\n            }\n        } else if (this.parseType === NonTerminal.CLASSES) {\n            if (this.detectionSymbol === Terminal.STATEMENTS_FILLER) {\n                return {symbolType: Terminal.STATEMENTS_FILLER};\n            } else if (this.detectionSymbol === Terminal.ATTRIBUTES) {\n                // simply split by the first :\n                const trimmed: string = this.trimReplaceString(this.stringStream);\n                const idx = trimmed.indexOf(\":\");\n                let attributeName: string;\n                let attributeType: string | null;\n                if (idx === -1) {\n                    attributeName = trimmed;\n                    attributeType = null;\n                } else {\n                    attributeName = trimmed.substring(0, idx).trim();\n                    if (idx === trimmed.length - 1) {\n                        attributeType = \"\";\n                    } else {\n                        attributeType = trimmed.substring(idx + 1, trimmed.length).trim();\n                    }\n                }\n                return {symbolType: Terminal.ATTRIBUTES, nodeCreationInformation: {\n                    attributeName: attributeName,\n                    attributeType: attributeType\n                }};\n            } else if (this.detectionSymbol === Terminal.COMMENT_MULTILINE) {\n                // multiline comments can only have spaces before the \"\\n\", and the space\n                const trimmed: string = this.trimReplaceString(this.stringStream);\n                return {symbolType: Terminal.COMMENT_MULTILINE, nodeCreationInformation: {\n                    commentContents: trimmed.substring(3, trimmed.length - 3)\n                }};\n            } else if (this.detectionSymbol === NonTerminal.FUNCTIONS) {\n                if (!this.stopAcceptingStringStream) {\n                    // didn't detect the colon, we therefore need to reject it\n                    return {symbolType: Terminal.STATEMENTS_FILLER};\n                }\n                // use the same parse range as the range of the functions\n                const functionDefnText: string = this.trimReplaceString(this.stringStream);\n                return {symbolType: NonTerminal.FUNCTIONS, nodeCreationInformation: {\n                    functionDefinitionText: functionDefnText,\n                    funcInnerRange: this.getRange(this.getTokenChRange(this.classOrFuncBodyParseStart).start, this.getTokenChRange(this.lastLineForEndCodeBlockIndex).start)\n                }};\n            } else {\n                throw Error(\"Not supported!\");\n            }\n        } else {\n            throw Error(\"Not supported!\");\n        }\n    }\n\n    private trimReplaceString(str: string): string {\n        return str.trim().replace(/\\\\\\n/g, \"\");\n    }\n\n    private updateCodeBlocksBracesAndSpacingsState(token: Token, currentTokIndex: number) {\n        if (token.tokenType === TokenType.SPACINGS) {\n            // only handle the newlines and indentations if not in any braces\n            if (this.bracesMatcher.currentDepth() === 0) {\n                // ok, we got spacings. now handle it\n                if (token.stringContents === \"\\n\" && !this.prevTokenEndsWithBackslash) {\n                    // we have new line. reset indentation\n                    this.mostRecentLineTokIndex = currentTokIndex;\n                    this.indentationCount = 0;\n                    this.continuousIndentAfterNewline = true;\n                } else if (this.continuousIndentAfterNewline) { // spaces and tabs\n                    // add indentation if continuous after new line\n                    this.indentationCount++;\n                }\n            }\n            this.prevTokenEndsWithBackslash = false;\n        } else if (token.tokenType === TokenType.BRACES) {\n            try {\n                this.bracesMatcher.next(token.stringContents);\n            } catch (e: any) {\n                if (e instanceof Error) {\n                    throw new CodeParsingError(\"Error during brace matching! \" + e.message);\n                }\n                throw e;\n            }\n            this.continuousIndentAfterNewline = false;\n            this.prevTokenEndsWithBackslash = false;\n        } else {\n            this.continuousIndentAfterNewline = false;\n\n            // handle continued lines correctly\n            this.prevTokenEndsWithBackslash = false;\n            if (token.stringContents.length > 0 && token.stringContents.charAt(token.stringContents.length - 1) === \"\\\\\") {\n                this.prevTokenEndsWithBackslash = true;\n            }\n        }\n    }\n}\n","import { Argument, Attributes, Classes, Comments, FunctionDeclaration, FunctionGroups, Functions, References, SyntaxNode, TopLevel } from \"../nodes\";\nimport { compare, Index, indexesToRange, rangeToEndIndex, rangeToStartIndex } from \"../utils\";\nimport { ASTGenericTokenizer, TextRange, TokenAction, TreeToken, TreeTokenType } from \"./ASTGenericTokenizer\";\n\nexport enum TokenizationMode {\n    NONE, // single token\n    TOP_LEVEL_ONLY, // only things immediately in top level will be resolved\n    FUNCTIONS_AND_CLASSES, // all functions, classes, and class member functions, and comments of functions\n    FUNCTIONS_AND_CLASSES_AND_ARGUMENTS, // same as above, but arguments of functions will also be resolved\n    EVERYTHING // everything, including things in function body, except function comments right after the function declaration (e.g Python), which causes potential conflict\n}\n\n\n/**\n * Faithful tokenizer such that it preserves the original text.\n */\nexport class ASTFaithfulTokenizer extends ASTGenericTokenizer {\n    private tokenizationMode: TokenizationMode;\n    private prevEndIndex: Index;\n    private excludeInnerRangeIfPossible: boolean;\n\n    constructor(mode: TokenizationMode, excludeInnerRangeIfPossible: boolean) {\n        super();\n        this.tokenizationMode = mode;\n        this.excludeInnerRangeIfPossible = excludeInnerRangeIfPossible;\n        this.prevEndIndex = {character: 0, line: 0};\n    }\n\n    protected pretokenize(tokenString: TreeToken[]): void {\n        this.prevEndIndex = this.getGlobalStartIndex();\n    }\n\n    protected posttokenize(tokenString: TreeToken[]): void {\n        // add remaining stuff to the token string, if exists\n        const diff = compare(this.prevEndIndex, this.getGlobalEndIndex());\n        if (diff === -1) {\n            tokenString.push({\n                stringContents: this.getCodeStringFromIndices(this.prevEndIndex, this.getGlobalEndIndex()),\n                tokenType: TreeTokenType.OTHERS,\n                range: indexesToRange(this.prevEndIndex, this.getGlobalEndIndex())\n            });\n        } else if (diff === 1) {\n            throw Error(\"Unexpected end index larger than global end!\");\n        }\n    }\n\n    protected convertIntoTokens(node: SyntaxNode, depth: number, previousNode: SyntaxNode | null, tokenText: TextRange, tokenPrefixText: TextRange | null, tokenSuffixText: TextRange | null): { prefixTokens?: TreeToken[]; suffixTokens?: TreeToken[]; action: TokenAction; } {\n        switch (this.tokenizationMode) {\n            case TokenizationMode.NONE:\n                // simply do not resolve the top level node\n                this.prevEndIndex = this.getGlobalEndIndex();\n                return {prefixTokens: [{stringContents: tokenText.text, tokenType: TreeTokenType.TOP_LEVEL, range: tokenText.range, originalNode: node}], action: TokenAction.TERMINATE};\n            case TokenizationMode.TOP_LEVEL_ONLY:\n                return this.convertTopLevel(node, depth, previousNode, tokenText, tokenPrefixText, tokenSuffixText);\n            case TokenizationMode.FUNCTIONS_AND_CLASSES:\n                return this.convertFunctionsAndClasses(node, depth, previousNode, tokenText, tokenPrefixText, tokenSuffixText);\n            case TokenizationMode.FUNCTIONS_AND_CLASSES_AND_ARGUMENTS:\n                return this.convertFunctionsAndClassesAndArguments(node, depth, previousNode, tokenText, tokenPrefixText, tokenSuffixText);\n            case TokenizationMode.EVERYTHING:\n                return this.convertEverything(node, depth, previousNode, tokenText, tokenPrefixText, tokenSuffixText);\n        }\n    }\n\n    protected handleFirstSuffixTokenIfNecessary(firstSuffixToken: TreeToken): TreeToken | null {\n        // add some fillers between the children and the first suffix token, for completeness\n        if (firstSuffixToken.range !== undefined) {\n            const range = firstSuffixToken.range;\n            const comparison: number = compare(this.prevEndIndex, rangeToStartIndex(range));\n            if (comparison === 1) {\n                throw Error(\"Invalid comparison! Expected previous end to be less than or equal to the current range.\");\n            } else if (comparison === -1) {\n                const fillRange = indexesToRange(this.prevEndIndex, rangeToStartIndex(range));\n                return {stringContents: this.getCodeString(fillRange), range: fillRange, tokenType: TreeTokenType.OTHERS};\n            } else {\n                return null;\n            }\n        }\n        return null;\n    }\n\n    protected handleLastSuffixTokenWithRangeIfNecessary(lastSuffixToken: TreeToken): void {\n        // flag the prev end ast the last suffix token\n        this.prevEndIndex = rangeToEndIndex(lastSuffixToken.range!);\n    }\n\n    private convertTopLevel(node: SyntaxNode, depth: number, previousNode: SyntaxNode | null, tokenText: TextRange, tokenPrefixText: TextRange | null, tokenSuffixText: TextRange | null): { prefixTokens?: TreeToken[]; suffixTokens?: TreeToken[]; action: TokenAction; } {\n        if (depth === 0) {\n            // no need to add anything, simply resolve\n            return {action: TokenAction.RESOLVE};\n        }\n\n        // translate the current node to tokens\n        if (node instanceof References) {\n            return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.REFERENCES, node), action: TokenAction.TERMINATE};\n        } else if (node instanceof Comments) {\n            // do not include comments that are a part of function groups\n            if (node.getParent() instanceof TopLevel) {\n                return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.COMMENTS, node), action: TokenAction.TERMINATE};\n            } else {\n                return {action: TokenAction.TERMINATE};\n            }\n        } else if (node instanceof Classes) {\n            if (this.excludeInnerRangeIfPossible && tokenPrefixText !== null) {\n                if (tokenSuffixText !== null) {\n                    return {\n                        prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.CLASS, node),\n                        suffixTokens: [{stringContents: tokenSuffixText.text, range: tokenSuffixText.range, tokenType: TreeTokenType.CLASS, originalNode: node}],\n                        action: TokenAction.TERMINATE\n                    };\n                } else {\n                    return {prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.CLASS, node), action: TokenAction.TERMINATE};\n                }\n            } else {\n                return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.CLASS, node), action: TokenAction.TERMINATE};\n            }\n            \n        } else if (node instanceof FunctionGroups) {\n            return {action: TokenAction.RESOLVE};\n        } else if (node instanceof Functions) {\n            if (this.excludeInnerRangeIfPossible && tokenPrefixText !== null) {\n                if (tokenSuffixText !== null) {\n                    return {\n                        prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.FUNCTION, node),\n                        suffixTokens: [{stringContents: tokenSuffixText.text, range: tokenSuffixText.range, tokenType: TreeTokenType.FUNCTION, originalNode: node}],\n                        action: TokenAction.TERMINATE\n                    };\n                } else {\n                    return {prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.FUNCTION, node), action: TokenAction.TERMINATE};\n                }\n            } else {\n                return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.FUNCTION, node), action: TokenAction.TERMINATE};\n            }\n        }\n\n        throw Error(\"Some scenarios not explored!\");\n    }\n\n    private convertFunctionsAndClasses(node: SyntaxNode, depth: number, previousNode: SyntaxNode | null, tokenText: TextRange, tokenPrefixText: TextRange | null, tokenSuffixText: TextRange | null): { prefixTokens?: TreeToken[]; suffixTokens?: TreeToken[]; action: TokenAction; } {\n        if (depth === 0) {\n            // no need to add anything, simply resolve\n            return {action: TokenAction.RESOLVE};\n        }\n\n        // translate the current node to tokens\n        if (node instanceof References) {\n            return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.REFERENCES, node), action: TokenAction.TERMINATE};\n        } else if (node instanceof Comments) {\n            // when not excluding inner range, the function will cover the contents\n            // therefore, we exclude comments directly in function groups, and the sibling rank is > 0 (which means it is a function comment, we exclude it)\n            if (this.excludeInnerRangeIfPossible || !(node.getParent() instanceof FunctionGroups) || node.getSiblingRank() === 0) {\n                return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.COMMENTS, node), action: TokenAction.TERMINATE};\n            } else {\n                return {action: TokenAction.TERMINATE};\n            }\n        } else if (node instanceof Classes) {\n            // try to split into prefix and suffix\n            if (tokenPrefixText !== null) {\n                if (tokenSuffixText !== null) {\n                    return {\n                        prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.CLASS, node),\n                        suffixTokens: [{stringContents: tokenSuffixText.text, range: tokenSuffixText.range, tokenType: TreeTokenType.CLASS, originalNode: node}],\n                        action: TokenAction.RESOLVE\n                    };\n                } else {\n                    return {prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.CLASS, node), action: TokenAction.RESOLVE};\n                }\n            } else {\n                return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.CLASS, node), action: TokenAction.RESOLVE};\n            }\n            \n        } else if (node instanceof Attributes) {\n            return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.ATTRIBUTE, node), action: TokenAction.TERMINATE};\n        } else if (node instanceof FunctionGroups) {\n            // simply resolve, nothing added\n            return {action: TokenAction.RESOLVE};\n        } else if (node instanceof Functions) {\n            // we don't have to resolve the functions\n            if (this.excludeInnerRangeIfPossible && tokenPrefixText !== null) {\n                if (tokenSuffixText !== null) {\n                    return {\n                        prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.FUNCTION, node),\n                        suffixTokens: [{stringContents: tokenSuffixText.text, range: tokenSuffixText.range, tokenType: TreeTokenType.FUNCTION, originalNode: node}],\n                        action: TokenAction.TERMINATE\n                    };\n                } else {\n                    return {prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.FUNCTION, node), action: TokenAction.TERMINATE};\n                }\n            } else {\n                return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.FUNCTION, node), action: TokenAction.TERMINATE};\n            }\n        }\n\n        throw Error(\"Some scenarios not explored!\");\n    }\n\n    private convertFunctionsAndClassesAndArguments(node: SyntaxNode, depth: number, previousNode: SyntaxNode | null, tokenText: TextRange, tokenPrefixText: TextRange | null, tokenSuffixText: TextRange | null): { prefixTokens?: TreeToken[]; suffixTokens?: TreeToken[]; action: TokenAction; } {\n        if (depth === 0) {\n            // no need to add anything, simply resolve\n            return {action: TokenAction.RESOLVE};\n        }\n\n        // translate the current node to tokens\n        if (node instanceof References) {\n            return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.REFERENCES, node), action: TokenAction.TERMINATE};\n        } else if (node instanceof Comments) {\n            // do not include comments that are a part of functions\n            if (node.getParent() instanceof Functions) {\n                return {action: TokenAction.TERMINATE};\n            } else {\n                return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.COMMENTS, node), action: TokenAction.TERMINATE};\n            }\n        } else if (node instanceof Classes) {\n            // try to split into prefix and suffix\n            if (tokenPrefixText !== null) {\n                if (tokenSuffixText !== null) {\n                    return {\n                        prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.CLASS, node),\n                        suffixTokens: [{stringContents: tokenSuffixText.text, range: tokenSuffixText.range, tokenType: TreeTokenType.CLASS, originalNode: node}],\n                        action: TokenAction.RESOLVE\n                    };\n                } else {\n                    return {prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.CLASS, node), action: TokenAction.RESOLVE};\n                }\n            } else {\n                return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.CLASS, node), action: TokenAction.RESOLVE};\n            }\n            \n        } else if (node instanceof Attributes) {\n            return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.ATTRIBUTE, node), action: TokenAction.TERMINATE};\n        } else if (node instanceof FunctionGroups) {\n            // simply resolve, nothing added\n            return {action: TokenAction.RESOLVE};\n        } else if (node instanceof Functions) {\n            // simply resolve, nothing added\n            return {action: TokenAction.RESOLVE};\n        } else if (node instanceof FunctionDeclaration) {\n            // resolve into prefix and suffix if possible. it is possible to have no prefixes or suffixes, since the function may have no arguments\n            if (tokenPrefixText !== null) {\n                if (tokenSuffixText !== null) {\n                    return {\n                        prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.FUNCTION_DEFINITION, node),\n                        suffixTokens: [{stringContents: tokenSuffixText.text, range: tokenSuffixText.range, tokenType: TreeTokenType.FUNCTION_DEFINITION, originalNode: node}],\n                        action: TokenAction.RESOLVE\n                    };\n                } else {\n                    return {prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.FUNCTION_DEFINITION, node), action: TokenAction.RESOLVE};\n                }\n            } else {\n                return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.FUNCTION_DEFINITION, node), action: TokenAction.TERMINATE};\n            }\n        } else if (node instanceof Argument) {\n            return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.ARGUMENT, node), action: TokenAction.TERMINATE};\n        }\n\n        throw Error(\"Some scenarios not explored!\");\n    }\n\n    private convertEverything(node: SyntaxNode, depth: number, previousNode: SyntaxNode | null, tokenText: TextRange, tokenPrefixText: TextRange | null, tokenSuffixText: TextRange | null): { prefixTokens?: TreeToken[]; suffixTokens?: TreeToken[]; action: TokenAction; } {\n        if (depth === 0) {\n            // no need to add anything, simply resolve\n            return {action: TokenAction.RESOLVE};\n        }\n\n        // translate the current node to tokens\n        if (node instanceof References) {\n            return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.REFERENCES, node), action: TokenAction.TERMINATE};\n        } else if (node instanceof Comments) {\n            // the other comments inside the function will cover the first comment belonging to a function (e.g Python docstring).\n            // therefore, we exclude comments directly in function groups, and the sibling rank is > 0 (which means it is a function comment, we exclude it)\n            if (!(node.getParent() instanceof FunctionGroups) || node.getSiblingRank() === 0) {\n                return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.COMMENTS, node), action: TokenAction.TERMINATE};\n            } else {\n                return {action: TokenAction.TERMINATE};\n            }\n        } else if (node instanceof Classes) {\n            // try to split into prefix and suffix\n            if (tokenPrefixText !== null) {\n                if (tokenSuffixText !== null) {\n                    return {\n                        prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.CLASS, node),\n                        suffixTokens: [{stringContents: tokenSuffixText.text, range: tokenSuffixText.range, tokenType: TreeTokenType.CLASS, originalNode: node}],\n                        action: TokenAction.RESOLVE\n                    };\n                } else {\n                    return {prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.CLASS, node), action: TokenAction.RESOLVE};\n                }\n            } else {\n                return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.CLASS, node), action: TokenAction.RESOLVE};\n            }\n            \n        } else if (node instanceof Attributes) {\n            return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.ATTRIBUTE, node), action: TokenAction.TERMINATE};\n        } else if (node instanceof FunctionGroups) {\n            // simply resolve, nothing added\n            return {action: TokenAction.RESOLVE};\n        } else if (node instanceof Functions) {\n            // simply resolve, nothing added\n            return {action: TokenAction.RESOLVE};\n        } else if (node instanceof FunctionDeclaration) {\n            // resolve into prefix and suffix if possible\n            if (tokenPrefixText !== null) {\n                if (tokenSuffixText !== null) {\n                    return {\n                        prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.FUNCTION_DEFINITION, node),\n                        suffixTokens: [{stringContents: tokenSuffixText.text, range: tokenSuffixText.range, tokenType: TreeTokenType.FUNCTION_DEFINITION, originalNode: node}],\n                        action: TokenAction.RESOLVE\n                    };\n                } else {\n                    return {prefixTokens: this.getPrefixTokens(tokenPrefixText, TreeTokenType.FUNCTION_DEFINITION, node), action: TokenAction.RESOLVE};\n                }\n            } else {\n                return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.FUNCTION_DEFINITION, node), action: TokenAction.TERMINATE};\n            }\n        } else if (node instanceof Argument) {\n            return {prefixTokens: this.getPrefixTokens(tokenText, TreeTokenType.ARGUMENT, node), action: TokenAction.TERMINATE};\n        }\n\n        throw Error(\"Some scenarios not explored!\");\n    }\n\n    private getPrefixTokens(tokenText: TextRange, tokenType: TreeTokenType, originalNode?: SyntaxNode): TreeToken[] {\n        const comparison: number = compare(this.prevEndIndex, rangeToStartIndex(tokenText.range));\n\n        let retTokens: TreeToken[];\n        if (comparison === 1) {\n            throw Error(\"Invalid comparison! Expected previous end to be less than or equal to the current range.\");\n        } else if (comparison === -1) {\n            const fillRange = indexesToRange(this.prevEndIndex, rangeToStartIndex(tokenText.range));\n            retTokens = [\n                {stringContents: this.getCodeString(fillRange), range: fillRange, tokenType: TreeTokenType.OTHERS},\n                {stringContents: tokenText.text, range: tokenText.range, tokenType: tokenType, originalNode: originalNode}\n            ];\n        } else {\n            retTokens = [{stringContents: tokenText.text, range: tokenText.range, tokenType: tokenType, originalNode: originalNode}];\n        }\n        this.prevEndIndex = rangeToEndIndex(tokenText.range); // update the previous end\n        return retTokens;\n    }\n\n    protected disableSubtreeParsing(): boolean {\n        return true;\n    }\n\n    protected includeIndentation(tokenString: TreeToken[], depth: number): void {\n        throw Error(\"Indentation not supported for faithful tokenizer!\");\n    }\n}","/**\n * StringExpressionMatcher class allows matching predefined expressions against\n * a stream of characters, processing one character at a time.\n */\nexport class StringExpressionMatcher {\n    private expressions: Record<string, string>;\n    private potentialMatches: Record<string, number[]>;\n\n    /**\n     * Constructs an StringExpressionMatcher instance.\n     *\n     * @param expressions - A record mapping keys to their respective matching strings.\n     * @throws Will throw an error if any validation fails:\n     *   - Duplicate matching strings.\n     *   - One matching string is a suffix of another.\n     *   - Matching strings are empty.\n     */\n    constructor(expressions: Record<string, string>) {\n        this.validateExpressions(expressions);\n        this.expressions = expressions;\n        this.potentialMatches = {} as Record<string, number[]>;\n\n        // Populate reverseMap for quick lookup of keys by their matching strings\n        for (const key of Object.keys(expressions)) {\n            this.potentialMatches[key] = [];\n        }\n    }\n\n    /**\n     * Processes the next character in the input stream.\n     *\n     * @param ch - The next character to process. Must be a single character string.\n     * @returns A single key if any matches are found; otherwise, `null`.\n     * @throws Will throw an error if the input character is not a single character string.\n     */\n    public next(ch: string): string | null{\n        if (ch.length !== 1) {\n            throw new Error(`Input to next() must be a single character. Received: \"${ch}\"`);\n        }\n\n        let matched: string | null = null;\n        for (const [key, expr] of Object.entries(this.expressions)) { // loop through the expressions\n            const progresses: number[] = this.potentialMatches[key];\n            progresses.push(0);\n            for (let i = progresses.length - 1; i >= 0; i--) { // reverse loop so that removal of an element won't affect the next element in the loop\n                if (ch === expr[progresses[i]]) { // matched\n                    progresses[i] += 1;\n                    // if fully matched, set and remove\n                    if (progresses[i] === expr.length) {\n                        if (matched !== null) {\n                            throw Error(\"Should not have expected this, since no repeating suffix!\");\n                        }\n                        matched = key;\n                        progresses.splice(i, 1);\n                    }\n                } else { // not match, remove it\n                    progresses.splice(i, 1);\n                }\n            }\n        }\n        return matched;\n    }\n\n    /**\n     * Resets the internal potential matches, clearing any ongoing match progress.\n     * This can be used to prevent overlapping matches.\n     */\n    public reset(): void {\n        for (const key of Object.keys(this.potentialMatches)) {\n            this.potentialMatches[key] = [];\n        }\n    }\n\n    /**\n     * Validates the input expressions to ensure no ambiguities in matching.\n     *\n     * @param expressions - The expressions to validate.\n     * @throws Will throw an error if:\n     *   - Any matching string is empty.\n     *   - There are duplicate matching strings.\n     *   - Any matching string is a suffix of another.\n     */\n    private validateExpressions(expressions: Record<string, string>): void {\n        const values = Object.values(expressions);\n        if (values.length === 0) {\n            throw new Error(\"Must have some expression to match.\");\n        }\n\n        // Check for empty strings\n        if (values.some(value => value.length === 0)) {\n            throw new Error(\"Matching strings must be non-empty.\");\n        }\n\n        // Check for suffix ambiguities\n        for (let i = 0; i < values.length; i++) {\n            for (let j = 0; j < values.length; j++) {\n                if (i === j) continue;\n                const strA = values[i];\n                const strB = values[j];\n                if (strA.endsWith(strB)) {\n                    throw new Error(`Ambiguous expressions: \"${strA}\" has \"${strB}\" as a suffix.`);\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets the length of the expression to be matched\n     * @param key \n     * @returns The length of the expression to be matched\n     */\n    public getLength(key: string): number {\n        return this.expressions[key].length;\n    }\n\n    /**\n     * Gets the maximum length of all expressions.\n     * @returns The maximum length.\n     */\n    public getMaxExpressionLength(): number {\n        let maxLength = 0;\n        for (const key in this.expressions) {\n            if (this.expressions.hasOwnProperty(key)) {\n                const length = this.expressions[key].length;\n                if (length > maxLength) {\n                    maxLength = length;\n                }\n            }\n        }\n        return maxLength;\n    }\n}","export class CodeParsingError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"CodeParsingError\";\n    }\n}","export type Braces = {\n    opening: string;\n    closing: string;\n};\n\n/**\n * Class representing a Braces Matcher.\n */\nexport class BracesMatcher {\n    private readonly openingToClosing: Map<string, string>;\n    private readonly closingToOpening: Map<string, string>;\n    private stack: string[];\n\n    /**\n     * Initializes a new instance of the BracesMatcher class.\n     * @param braces - An array of brace pairs, each with an opening and closing character.\n     * @throws Will throw an error if any opening or closing character is not exactly one character long,\n     *         or if there are duplicate opening or closing characters.\n     */\n    constructor(braces: Braces[]) {\n        this.openingToClosing = new Map<string, string>();\n        this.closingToOpening = new Map<string, string>();\n        this.stack = [];\n\n        // Validate and populate the maps\n        const tempIntersectionCheck: string[] = [];\n        for (const brace of braces) {\n            const { opening, closing } = brace;\n\n            // Ensure both opening and closing are single characters\n            if (opening.length !== 1) {\n                throw new Error(`Opening brace \"${opening}\" must be exactly one character.`);\n            }\n            if (closing.length !== 1) {\n                throw new Error(`Closing brace \"${closing}\" must be exactly one character.`);\n            }\n\n            // Check for uniqueness\n            if (tempIntersectionCheck.includes(opening)) {\n                throw new Error(`Opening brace \"${opening}\" repeated!`);\n            }\n            tempIntersectionCheck.push(opening);\n            if(tempIntersectionCheck.includes(closing)) {\n                throw new Error(`Closing brace \"${closing}\" repeated!`);\n            }\n\n            this.openingToClosing.set(opening, closing);\n            this.closingToOpening.set(closing, opening);\n        }\n    }\n\n    /**\n     * Processes the next character in the stream.\n     * @param ch - The next character to process.\n     * @returns The current depth of opened braces after processing the character.\n     * @throws Will throw an error if the character length is not one,\n     *         or if there is a mismatch in the braces.\n     */\n    public next(ch: string): number {\n        if (ch.length !== 1) {\n            throw new Error(`Input character \"${ch}\" must be exactly one character long.`);\n        }\n\n        if (this.openingToClosing.has(ch)) {\n            // Character is an opening brace\n            this.stack.push(ch);\n        } else if (this.closingToOpening.has(ch)) {\n            // Character is a closing brace\n            if (this.stack.length === 0) {\n                throw new Error(`Unmatched closing brace \"${ch}\" encountered with no corresponding opening brace.`);\n            }\n\n            const lastOpening = this.stack[this.stack.length - 1];\n            const expectedClosing = this.openingToClosing.get(lastOpening);\n\n            if (ch === expectedClosing) {\n                this.stack.pop();\n            } else {\n                throw new Error(\n                    `Mismatched closing brace \"${ch}\". Expected \"${expectedClosing}\" to match opening brace \"${lastOpening}\".`\n                );\n            }\n        } else {\n            throw new Error(`Invalid brace: ${ch}`);\n        }\n        // If character is neither opening nor closing, do nothing\n\n        return this.stack.length;\n    }\n\n    /**\n     * Resets the internal state of the BracesMatcher.\n     */\n    public reset(): void {\n        this.stack = [];\n    }\n\n    /**\n     * Gets the current depth of opened braces.\n     * @returns The number of currently opened braces awaiting closure.\n     */\n    public currentDepth(): number {\n        return this.stack.length;\n    }\n}","import { SyntaxNode, TopLevel } from \"../nodes\";\nimport { contains, containsIndex, Range, Index, rangeToIndexes, getMaxRange } from \"../utils\";\n\nexport class AbstractSyntaxTree {\n    private root: TopLevel;\n    public sourceLines: string[];\n\n    /**\n     * Constructs an AbstractSyntaxTree.\n     * @param root The top-level node.\n     * @param sourceLines The source code split into lines.\n     */\n    constructor(root: TopLevel, sourceLines: string[]) {\n        this.root = root;\n        this.sourceLines = sourceLines;\n    }\n\n    /**\n     * Retrieves the source text within the specified range.\n     * @param start_line Starting line number (0-based).\n     * @param start_character Starting character number (0-based).\n     * @param end_line Ending line number (0-based).\n     * @param end_character Ending character number (0-based).\n     * @returns The extracted source text.\n     */\n    getSourceText(\n        start_line: number,\n        start_character: number,\n        end_line: number,\n        end_character: number\n    ): string {\n        if (\n            start_line < 0 ||\n            end_line > this.sourceLines.length ||\n            start_line > end_line ||\n            (start_line === end_line && start_character > end_character)\n        ) {\n            throw new Error(\"Invalid range specified. The start index must come before the end index, and the start index and end index must be contained inside the total range.\");\n        }\n        if ((end_line === this.sourceLines.length && end_character !== 0)\n            || (end_line < this.sourceLines.length && end_character > this.sourceLines[end_line].length)) {\n            throw new Error(\"Invalid range specified. The end character is not a valid character.\");\n        }\n        if (start_character > this.sourceLines[start_line].length) {\n            throw new Error(\"Invalid range specified. The start character is not a valid character.\")\n        }\n\n        // Need to take minimum because of \"virtual\" \\n at the last line.\n        const lines: string[] = this.sourceLines.slice(start_line, Math.min(end_line + 1, this.sourceLines.length));\n        if (end_line == this.sourceLines.length) { // Readjust\n            lines.push(\"\");\n        }\n\n        // Adjust the first and last lines based on character positions\n        if (lines.length === 1) {\n            return lines[0].substring(start_character, end_character);\n        }\n\n        lines[0] = lines[0].substring(start_character);\n        lines[lines.length - 1] = lines[lines.length - 1].substring(0, end_character);\n\n        return lines.join(\"\\n\");\n    }\n\n    /**\n     * Gets the source text from range\n     * @param range The range\n     * @returns The source text\n     */\n    getSourceTextFromRange(range: Range): string {\n        return this.getSourceText(range.start_line, range.start_character, range.end_line, range.end_character);\n    }\n\n    /**\n     * Gets the root node of the AST.\n     */\n    public getRoot(): TopLevel {\n        return this.root;\n    }\n\n    /**\n     * Gets the smallest node with .getRange() that contains the range.\n     */\n    public getSmallestNodeContains(range: Range): SyntaxNode {\n        let node: SyntaxNode = this.root;\n        outer: while (true) {\n            for (const child of node.listChildren()) {\n                if (contains(child.getRange(), range)) {\n                    node = child;\n                    continue outer;\n                }\n            }\n            return node; // can't find, directly return\n        }\n    }\n\n    /**\n     * Gets the smallest node with .getRange() that contains the index, if there are no\n     * termination conditions along the way. Otherwise, if some terminate conditions are\n     * met, terminate early and immediately return the node that triggered the termination.\n     * \n     * @param index The index that the returned node must contain\n     * @param terminationCondition A function to evaluate whether the node satisifes the termination condition. Returns true if terminate, or else return false. Can be null if no termination conditions are possible.\n     * @returns The found node.\n     */\n    public getNodeContainsIndex(index: Index, terminationCondition: ((node: SyntaxNode) => boolean) | null): SyntaxNode {\n        let node: SyntaxNode = this.root;\n        outer: while (true) {\n            // see if termination condition met\n            if (terminationCondition !== null && terminationCondition(node)) {\n                return node; // terminate\n            }\n\n            for (const child of node.listChildren()) {\n                if (containsIndex(child.getRange(), index)) {\n                    node = child;\n                    continue outer;\n                }\n            }\n            return node; // can't find, directly return\n        }\n    }\n\n    /**\n     * Gets the max range as indices\n     * @returns The max range as start end indices.\n     */\n    getMaxRangeAsIndices(): {start: Index, end: Index} {\n        return rangeToIndexes(getMaxRange(this.sourceLines));\n    }\n}","import { AbstractSyntaxTree } from \"./AbstractSyntaxTree\";\nimport { Range, Index, getCharacter, getMaxRange, mergeRanges, CharacterRange } from \"../utils\";\nimport { Argument, Attributes, Classes, Comments, FunctionDeclaration, FunctionGroups, Functions, References, SyntaxNode, TopLevel } from \"../nodes\";\nimport { CodeParsingError } from \"../CodeParsingError\";\nimport { CodeParserImplError } from \"../CodeParserImplError\";\nimport { Token, TokenRange, NonTerminal, Terminal, isTerminal, SymbolAdditionDirective } from \"./ParsingTypes\";\nimport { AbstractTokenizer } from \"./AbstractTokenizer\";\n\n/**\n * AbstractParser is an abstract class responsible for parsing source code\n * into an AbstractSyntaxTree. It contains the general parsing logic and\n * delegates language-specific parsing to abstract methods.\n */\nexport abstract class AbstractParser {\n    private sourceLines: string[] = [];\n    private positionMap: Index[] = [];\n    private numChars: number = 0;\n    private sourceTokens: Token[] = [];\n\n    /**\n     * Parses the given source code lines into an AbstractSyntaxTree.\n     * @param codeLines Array of strings representing the source code split by lines.\n     * @returns An AbstractSyntaxTree representing the parsed code.\n     */\n    parse(codeLines: string[]): AbstractSyntaxTree {\n        // check empty\n        if (codeLines.length === 0 || (codeLines.length === 1 && codeLines[0].length === 0)) {\n            throw new CodeParsingError(\"Cannot parse empty string!\");\n        }\n\n        // initialize\n        this.sourceLines = codeLines;\n        const tokenizer: AbstractTokenizer = this.preparseGetTokenizer();\n        this.positionMap = [];\n        codeLines.forEach((line: string, lineIndex: number) => { // a mapping from the indices of flattened string to the lines and characters.\n            for (let character = 0; character <= line.length; character++) {\n                this.positionMap.push({line: lineIndex, character: character});\n\n                // call the tokenizer\n                if (character < line.length) {\n                    tokenizer.next(line.charAt(character));\n                } else {\n                    tokenizer.next(\"\\n\");\n                }\n            }\n        });\n        this.numChars = this.positionMap.length; // how many characters there are\n        this.positionMap.push({line: codeLines.length, character: 0}); // last character (although resolves to nothing in getCharacter) for completeness, as we need it for closing.\n        tokenizer.next(null); // indicate the end\n        this.sourceTokens = tokenizer.getTokens();\n        this.preparse(codeLines, this.sourceTokens); // initialize any necessary thing\n\n        // prepare args\n        const maxRange = getMaxRange(this.sourceLines);\n        const rootNode = new TopLevel(maxRange);\n        const ast = new AbstractSyntaxTree(rootNode, this.sourceLines);\n\n        // parse now\n        this.parseNonTerminal(NonTerminal.TOP_LEVEL, rootNode, {startTok: 0, endTok: this.sourceTokens.length}, 0);\n        return ast;\n    }\n\n    /**\n     * Gets the character range corresponding to the token at the token index.\n     * @param tokIdx The index of the token in the tokenized source code.\n     * @returns The character range\n     */\n    getTokenChRange(tokIdx: number): CharacterRange {\n        return this.sourceTokens[tokIdx].characterRange;\n    }\n\n    /**\n     * Converts the character index to the index.\n     * @param chIndex The character index.\n     * @returns The index.\n     */\n    getIndex(chIndex: number): Index {\n        return this.positionMap[chIndex];\n    }\n\n    /**\n     * Gets the range with ends start index and end index.\n     * @param chStartIdx The character start index.\n     * @param chEndIdx The character end index.\n     */\n    getRange(chStartIdx: number, chEndIdx: number): Range {\n        const start = this.getIndex(chStartIdx);\n        const end = this.getIndex(chEndIdx);\n        return {\n            start_line: start.line, start_character: start.character,\n            end_line: end.line, end_character: end.character\n        };\n    }\n\n    /**\n     * Gets the substring inside the range starting from start index and ending in end index.\n     * @param chStartIdx The character start index.\n     * @param chEndIdx The character end index.\n     */\n    getSubstring(chStartIdx: number, chEndIdx: number): string {\n        if (chStartIdx > chEndIdx) {\n            throw Error(\"Invalid start end range!\");\n        }\n\n        let str: string = \"\";\n        for(let i = chStartIdx; i < chEndIdx; i++) {\n            str += this.getCharacterFromIndex(i);\n        }\n        return str;\n    }\n\n    /**\n     * Gets the character at the character index.\n     * @param chIndex The character index.\n     * @returns The character.\n     */\n    getCharacterFromIndex(chIndex: number): string {\n        return getCharacter(this.sourceLines, this.getIndex(chIndex));\n    }\n\n    /**\n     * Gets the string length of the code.\n     * @returns The string length.\n     */\n    getCodeLength(): number {\n        return this.numChars;\n    }\n\n    /**\n     * Prepares the parser before parsing starts. Can be used to detect indentation, etc.\n     * Must be implemented by subclasses.\n     */\n    protected abstract preparse(codeLines: string[], tokens: Token[]): void;\n\n    /**\n     * Gets the tokenizer for preparsing.\n     * @returns The tokenizer used.\n     */\n    protected abstract preparseGetTokenizer(): AbstractTokenizer;\n\n    /**\n     * Parses a non-terminal symbol within the given range and attaches nodes to the parent.\n     * @param nonTerminal The non-terminal symbol to parse.\n     * @param parent The parent SyntaxNode to attach child nodes.\n     * @param tokRange The range within which to parse.\n     * @param depth The current depth of the parsing tree.\n     * @throws CodeParsingError if there is an error during the code parsing and the API implementation has detected it.\n     *         CodeParserImplError if there is an error during the code parsing which is caused by incorrect implementation of the abstract parser functions.\n     *         Error if some other errors occur (probably problems or bugs in the WebASTParser library itself)\n     */\n    private parseNonTerminal(nonTerminal: NonTerminal, parent: SyntaxNode, tokRange: TokenRange, depth: number): void {\n        let currentTokIndex: number = tokRange.startTok;\n        let parsedEndTokIndex: number = tokRange.startTok; // How much tokens are parsed and accepted into some symbol. The parsed tokens are [startTok, parsedEndTokIndex). Initially no tokens are parsed.\n        this.resetDetectionState(tokRange.startTok, nonTerminal); // Reset the detection state\n\n        // things to keep track of when parsing the code\n        const state: (Terminal | NonTerminal)[] = []; // The state the parsing (resolving) of the current non terminal. Used to match the production rules\n        const ntParseRange: (TokenRange | null)[] = []; // Same length as state. Note that may be null if its non-terminal.\n        const symbolRange: TokenRange[] = []; // Same length. Keeps track of the range (in terms of tokens) the symbol has\n        const nodeCreationInformation: (Record<string, any> | undefined)[] = [];\n\n        // Loop through the tokens and partition the tokens into contiguous chunks of symbols\n        let tokenBuffer: Token[] = [];\n        while (currentTokIndex < tokRange.endTok) {\n            const token: Token = this.sourceTokens[currentTokIndex];\n            tokenBuffer.push(token); // add to the buffer\n\n            // update current token stream state\n            ({parsedEndTokIndex, tokenBuffer} = this.updateTokenStreamState(depth, nonTerminal, tokenBuffer, parsedEndTokIndex, currentTokIndex, false, state, ntParseRange, symbolRange, nodeCreationInformation));\n            \n            // go to next token\n            currentTokIndex++;\n        }\n        // conclude here\n        ({parsedEndTokIndex, tokenBuffer} = this.updateTokenStreamState(depth, nonTerminal, tokenBuffer, parsedEndTokIndex, currentTokIndex, true, state, ntParseRange, symbolRange, nodeCreationInformation));\n\n        // Now we check whether there are dangling non-parsed stuff\n        if (parsedEndTokIndex !== tokRange.endTok) {\n            throw new CodeParsingError(\"Invalid code syntax! Contains some non-parsed portions.\");\n        }\n\n        // Validate the parsed symbols\n        switch (nonTerminal) {\n            case NonTerminal.TOP_LEVEL:\n                this.validateParsingStateTopLevel(state);\n                break;\n            case NonTerminal.CLASSES:\n                this.validateParsingStateClasses(state);\n                break;\n            case NonTerminal.FUNCTIONS:\n                this.validateParsingStateFunctions(state);\n                break;\n            case NonTerminal.FUNCTION_BODY:\n                this.validateParsingStateFunctionBody(state);\n                break;\n            case NonTerminal.FUNCTION_DECLARATION:\n                this.validateParsingStateFunctionDeclaration(state);\n                break;\n            default:\n                throw Error(\"Invalid non terminal! Should not have happened.\");\n        }\n\n        // Create the nodes if necessary\n        const childNodes: (SyntaxNode | null)[] = [];\n        for (let i = 0; i < state.length; i++) {\n            childNodes.push(this.resolveIntoNode(state[i], symbolRange[i], nodeCreationInformation[i]));\n        }\n\n\n        // Full parse. We add to the tree and recurse.\n        if (nonTerminal === NonTerminal.FUNCTIONS){ // special functions case\n            // parse function declaration, and then function body\n            const results = this.getFirstLast(state);\n            parent.addChild(childNodes[results.first]!);\n            this.parseNonTerminal(NonTerminal.FUNCTION_DECLARATION, childNodes[results.first]!, ntParseRange[results.first]!, depth + 1);\n            this.parseNonTerminal(NonTerminal.FUNCTION_BODY, parent, ntParseRange[results.last]!, depth + 1); // things in the function body will be added directly to the function itself\n            // (expect possibly for the first multiline comment, which is added to the function group)\n        } else { // the remaining possibly have multiple children or none\n            const checkCommentFunctionPair: boolean = this.isCommentBeforeFunction() && (nonTerminal === NonTerminal.TOP_LEVEL || nonTerminal === NonTerminal.CLASSES);\n            const checkFirstCommentInFunction: boolean = (!this.isCommentBeforeFunction()) && nonTerminal === NonTerminal.FUNCTION_BODY;\n            let danglingMultilineComment: Comments | null = null;\n            let isFirst: boolean = true;\n\n            // Add the nodes to the parent\n            for (let i = 0; i < state.length; i++) { // Allowed to be empty. Add the syntax nodes to the parent\n                if (state[i] === Terminal.FILLER) {\n                    continue; // omit filler (e.g whitespaces)\n                }\n\n                const ani = childNodes[i];\n                if (state[i] === Terminal.STATEMENTS_FILLER) {\n                    isFirst = false; // statements filler do affect whether the comment belongs to the function\n                    if (nonTerminal === NonTerminal.FUNCTION_BODY && parent instanceof Functions) {\n                        (parent as Functions).flagHaveFunctionBody(); // got some statements inside the function, flag it.\n                    }\n                    continue; // omit statements filler\n                }\n                \n                if (ani instanceof SyntaxNode) {\n                    if (nonTerminal === NonTerminal.FUNCTION_BODY && parent instanceof Functions) {\n                        // try to check if something to be added, hence flagging the function body\n                        if (!(ani instanceof Comments) || !checkFirstCommentInFunction || !ani.isMultiLine || !isFirst) {\n                            // ok, the only exception is when the node to add is a multiline comment in the first statement\n                            // after function declaration, and detection of first comments is enabled.\n                            parent.flagHaveFunctionBody();\n                        }\n                    }\n\n                    if (ani instanceof Comments) {\n                        if (checkCommentFunctionPair && danglingMultilineComment !== null) {\n                            // add previous dangling comment\n                            parent.addChild(danglingMultilineComment);\n                            danglingMultilineComment = null;\n                        }\n\n                        if (checkCommentFunctionPair && ani.isMultiLine) {\n                            danglingMultilineComment = ani; // we await whether the next is function or not, so we don't immediately add\n                        } else if (checkFirstCommentInFunction && ani.isMultiLine && isFirst) {\n                            parent.getParent()!.addChild(ani); // when FUNCTION_BODY is being parsed, the parent is a Functions, and its parent is FunctionGroups. The comment belongs to the FunctionGroups.\n                        } else {\n                            parent.addChild(ani);\n                        }\n                    } else if (ani instanceof Functions) {\n                        if (checkCommentFunctionPair && danglingMultilineComment !== null) {\n                            // we have a previous multiline comment before the function.\n                            const rangeUnion: Range = mergeRanges([danglingMultilineComment.getRange(), ani.getRange()]);\n                            const funcGp: FunctionGroups = new FunctionGroups(rangeUnion); // function group's range is the smallest range containing union of both\n                            funcGp.addChild(danglingMultilineComment);\n                            funcGp.addChild(ani); // contains both\n                            danglingMultilineComment = null; // invalidate\n                            parent.addChild(funcGp);\n                        } else {\n                            // no dangling multiline comment, or is not the correct mode. we directly add\n                            const funcGp: FunctionGroups = new FunctionGroups(ani.getRange());\n                            funcGp.addChild(ani);\n                            parent.addChild(funcGp);\n                        }\n                    } else {\n                        if (checkCommentFunctionPair && danglingMultilineComment !== null) {\n                            // add previous dangling comment\n                            parent.addChild(danglingMultilineComment);\n                            danglingMultilineComment = null;\n                        }\n\n                        // add regardless\n                        parent.addChild(ani);\n                    }\n                    isFirst = false;\n                }\n            }\n\n            // add the dangling comment if it still exists (outside for loop)\n            if (danglingMultilineComment !== null) {\n                parent.addChild(danglingMultilineComment);\n            }\n\n            // Recursion\n            for (let i = 0; i < state.length; i++) {\n                if (!isTerminal(state[i])) {\n                    const symbol: NonTerminal = state[i] as NonTerminal;\n                    const ani = childNodes[i];\n                    const subnode: SyntaxNode = (ani instanceof SyntaxNode) ? ani: parent; // Directly add to parent if null\n                    this.parseNonTerminal(symbol, subnode, ntParseRange[i]!, depth + 1);\n                }\n            }\n        }\n    }\n\n    private updateTokenStreamState(depth: number, nonTerminal: NonTerminal, tokenBuffer: Token[], \n                                   parsedEndTokIndex: number, currentTokIndex: number, isConclusion: boolean,\n                                   stateHistory: (Terminal | NonTerminal)[], ntParseRange: (TokenRange | null)[],\n                                   symbolRange: TokenRange[], nodeCreationInformation: (Record<string, any> | undefined)[]): {parsedEndTokIndex: number, tokenBuffer: Token[]} {\n        // detect symbol here\n        const token: Token | null = isConclusion ? null : tokenBuffer[tokenBuffer.length - 1];\n        let detectionResult: SymbolAdditionDirective | null;\n        switch (nonTerminal) {\n            case NonTerminal.TOP_LEVEL:\n                detectionResult = this.detectTopLevelSymbol(stateHistory, token, currentTokIndex, depth);\n                break;\n            case NonTerminal.CLASSES:\n                detectionResult = this.detectClassesSymbol(stateHistory, token, currentTokIndex, depth);\n                break;\n            case NonTerminal.FUNCTIONS:\n                detectionResult = this.detectFunctionsSymbol(stateHistory, token, currentTokIndex, depth);\n                break;\n            case NonTerminal.FUNCTION_BODY:\n                detectionResult = this.detectFunctionBodySymbol(stateHistory, token, currentTokIndex, depth);\n                break;\n            case NonTerminal.FUNCTION_DECLARATION:\n                detectionResult = this.detectFunctionDeclarationSymbol(stateHistory, token, currentTokIndex, depth);\n                break;\n            default:\n                throw Error(\"Invalid non terminal! Should not have happened.\");\n        }\n\n        // now manage the result\n        if (detectionResult === null) {\n            return {parsedEndTokIndex, tokenBuffer}; // no symbols detected\n        }\n\n        // check return correctness\n        if (detectionResult.symbol.symbolType === NonTerminal.TOP_LEVEL) {\n            throw new CodeParserImplError(\"Cannot detect TOP_LEVEL since it must be the root!\");\n        }\n        if (detectionResult.secondSymbol !== undefined && detectionResult.secondSymbol.symbolType === NonTerminal.TOP_LEVEL) {\n            throw new CodeParserImplError(\"Cannot detect TOP_LEVEL since it must be the root!\");\n        }\n        if (detectionResult.secondSymbol !== undefined && tokenBuffer.length < 2) {\n            throw new CodeParserImplError(\"The token buffer must have at least length >= 2 to potentially split into two non-empty parts!\");\n        }\n        if ((detectionResult.secondSymbolLen !== undefined) && (detectionResult.secondSymbolLen >= tokenBuffer.length)) {\n            throw new CodeParserImplError(\"The length of the second symbol must be strictly less than the length of the token buffer to split into two non-empty parts!\");\n        }\n        if ((detectionResult.secondSymbolLen !== undefined) && (detectionResult.secondSymbolLen < 1)) {\n            throw new CodeParserImplError(\"The length of the second symbol must be >= 1 to split into two non-empty parts!\");\n        }\n        if (detectionResult.firstTwoSymbolsEndBufferLen !== undefined) {\n            if (detectionResult.secondSymbol === undefined || detectionResult.secondSymbolLen === undefined) {\n                throw new CodeParserImplError(\"If it were the case that the remaning buffer length after the first two symbols is specified, it must be the case that the second symbol's information be fully given.\");\n            }\n            if (detectionResult.firstTwoSymbolsEndBufferLen < 1) {\n                throw new CodeParserImplError(\"The length of the remaining buffer has to be >= 1 to split into three non-empty parts!\");\n            }\n            if (detectionResult.firstTwoSymbolsEndBufferLen + detectionResult.secondSymbolLen >= tokenBuffer.length) {\n                throw new CodeParserImplError(\"The secondSymbolLen along with the firstTwoSymbolsEndBufferLen must be that the buffer splits into three non-empty parts, including the first symbol.\");\n            }\n        }\n\n        // manage the buffer now\n        if (detectionResult.secondSymbol === undefined && detectionResult.secondSymbolLen === undefined) {\n            // only have one symbol, and the only symbol isn't truncated\n            stateHistory.push(detectionResult.symbol.symbolType);\n            symbolRange.push({startTok: parsedEndTokIndex, endTok: parsedEndTokIndex + tokenBuffer.length});\n            if (!isTerminal(detectionResult.symbol.symbolType) && detectionResult.symbol.parseRange === undefined) {\n                detectionResult.symbol.parseRange = symbolRange[symbolRange.length - 1]; // set to be equal to the symbol range, if its non-terminal and not given\n            }\n            ntParseRange.push(detectionResult.symbol.parseRange === undefined ? null : detectionResult.symbol.parseRange);\n            nodeCreationInformation.push(detectionResult.symbol.nodeCreationInformation);\n            this.assertParseRangeCorrectness(stateHistory[stateHistory.length - 1], ntParseRange[ntParseRange.length - 1], symbolRange[symbolRange.length - 1]);\n\n            // update the end and clear buffer\n            parsedEndTokIndex += tokenBuffer.length;\n            tokenBuffer = [];\n        } else if (detectionResult.firstTwoSymbolsEndBufferLen !== undefined) {\n            // two symbols, but we retain the buffer specified by firstTwoSymbolsEndBufferLen\n            const firstSymbolStart = 0;\n            const firstSecondSymbolSep = 0 + tokenBuffer.length - detectionResult.firstTwoSymbolsEndBufferLen - detectionResult.secondSymbolLen!;\n            const secondSymbolEnd = 0 + tokenBuffer.length - detectionResult.firstTwoSymbolsEndBufferLen;\n            const allEnd = tokenBuffer.length;\n\n            // push the first symbol\n            stateHistory.push(detectionResult.symbol.symbolType);\n            symbolRange.push({startTok: parsedEndTokIndex + firstSymbolStart, endTok: parsedEndTokIndex + firstSecondSymbolSep});\n            if (!isTerminal(detectionResult.symbol.symbolType) && detectionResult.symbol.parseRange === undefined) {\n                detectionResult.symbol.parseRange = symbolRange[symbolRange.length - 1]; // set to be equal to the symbol range, if its non-terminal and not given\n            }\n            ntParseRange.push(detectionResult.symbol.parseRange === undefined ? null : detectionResult.symbol.parseRange);\n            nodeCreationInformation.push(detectionResult.symbol.nodeCreationInformation);\n            this.assertParseRangeCorrectness(stateHistory[stateHistory.length - 1], ntParseRange[ntParseRange.length - 1], symbolRange[symbolRange.length - 1]);\n\n            // push the second symbol\n            stateHistory.push(detectionResult.secondSymbol!.symbolType);\n            symbolRange.push({startTok: parsedEndTokIndex + firstSecondSymbolSep, endTok: parsedEndTokIndex + secondSymbolEnd});\n            if (!isTerminal(detectionResult.secondSymbol!.symbolType) && detectionResult.secondSymbol!.parseRange === undefined) {\n                detectionResult.secondSymbol!.parseRange = symbolRange[symbolRange.length - 1]; // set to be equal to the symbol range, if its non-terminal and not given\n            }\n            ntParseRange.push(detectionResult.secondSymbol!.parseRange === undefined ? null : detectionResult.secondSymbol!.parseRange);\n            nodeCreationInformation.push(detectionResult.secondSymbol!.nodeCreationInformation);\n            this.assertParseRangeCorrectness(stateHistory[stateHistory.length - 1], ntParseRange[ntParseRange.length - 1], symbolRange[symbolRange.length - 1]);\n\n            // update the end and truncate the buffer\n            tokenBuffer = tokenBuffer.slice(secondSymbolEnd, allEnd);\n            parsedEndTokIndex += secondSymbolEnd;\n        } else {\n            // two symbols, and the second symbol might be not finished. we further split into cases\n            if (detectionResult.secondSymbolLen === undefined) {\n                detectionResult.secondSymbolLen = 1;\n            }\n\n            stateHistory.push(detectionResult.symbol.symbolType);\n            symbolRange.push({startTok: parsedEndTokIndex, endTok: parsedEndTokIndex + tokenBuffer.length - detectionResult.secondSymbolLen});\n            if (!isTerminal(detectionResult.symbol.symbolType) && detectionResult.symbol.parseRange === undefined) {\n                detectionResult.symbol.parseRange = symbolRange[symbolRange.length - 1]; // set to be equal to the symbol range, if its non-terminal and not given\n            }\n            ntParseRange.push(detectionResult.symbol.parseRange === undefined ? null : detectionResult.symbol.parseRange);\n            nodeCreationInformation.push(detectionResult.symbol.nodeCreationInformation);\n            this.assertParseRangeCorrectness(stateHistory[stateHistory.length - 1], ntParseRange[ntParseRange.length - 1], symbolRange[symbolRange.length - 1]);\n            if (detectionResult.secondSymbol === undefined) {\n                // only use the partial buffer, the rest is still up to parse\n                parsedEndTokIndex += (tokenBuffer.length - detectionResult.secondSymbolLen);\n                tokenBuffer = tokenBuffer.slice(tokenBuffer.length - detectionResult.secondSymbolLen, tokenBuffer.length);\n            } else {\n                // conclude two symbols\n                stateHistory.push(detectionResult.secondSymbol.symbolType);\n                symbolRange.push({startTok: parsedEndTokIndex + tokenBuffer.length - detectionResult.secondSymbolLen, endTok: parsedEndTokIndex + tokenBuffer.length});\n                if (!isTerminal(detectionResult.secondSymbol.symbolType) && detectionResult.secondSymbol.parseRange === undefined) {\n                    detectionResult.secondSymbol.parseRange = symbolRange[symbolRange.length - 1]; // set to be equal to the symbol range, if its non-terminal and not given\n                }\n                ntParseRange.push(detectionResult.secondSymbol.parseRange === undefined ? null : detectionResult.secondSymbol.parseRange);\n                nodeCreationInformation.push(detectionResult.secondSymbol.nodeCreationInformation);\n                this.assertParseRangeCorrectness(stateHistory[stateHistory.length - 1], ntParseRange[ntParseRange.length - 1], symbolRange[symbolRange.length - 1]);\n\n                // update the end and clear buffer\n                parsedEndTokIndex += tokenBuffer.length;\n                tokenBuffer = [];\n            }\n        }\n\n        return {parsedEndTokIndex, tokenBuffer};\n    }\n\n    private assertParseRangeCorrectness(symbolType: Terminal | NonTerminal, parseRange: TokenRange | null, symbolRange: TokenRange) {\n        if (!isTerminal(symbolType)) {\n            if (parseRange === null) {\n                throw new CodeParserImplError(\"If detected type is not a terminal, must return parseRange non null to resolve further by recursion.\");\n            }\n            if (!((symbolRange.startTok <= parseRange.startTok) && (parseRange.endTok <= symbolRange.endTok))) {\n                throw new CodeParserImplError(\"The parse range of a non terminal must be contained inside the range used for detection.\");\n            }\n        } else {\n            if (parseRange !== null) {\n                throw new CodeParserImplError(\"Terminal types does not have a parseRange since it doesn't have to be resolved.\");\n            }\n        }\n    }\n\n    private resolveIntoNode(detectedType: Terminal | NonTerminal, detectedRange: TokenRange, nodeCreationInformation: Record<string, any> | undefined): SyntaxNode | null {\n        const range: Range = this.getRange(this.sourceTokens[detectedRange.startTok].characterRange.start, this.sourceTokens[detectedRange.endTok - 1].characterRange.end);\n        if (detectedType === Terminal.ARGUMENT) {\n            return this.createArgumentNode(range, nodeCreationInformation);\n        } else if (detectedType === Terminal.ATTRIBUTES) {\n            return this.createAttributesNode(range, nodeCreationInformation);\n        } else if (detectedType === Terminal.COMMENT_MULTILINE) {\n            return this.createCommentsNode(range, true, nodeCreationInformation);\n        } else if (detectedType === Terminal.COMMENT_SINGLELINE) {\n            return this.createCommentsNode(range, false, nodeCreationInformation);\n        } else if (detectedType === Terminal.REFERENCES) {\n            return this.createReferencesNode(range, nodeCreationInformation);\n        } else if (detectedType === Terminal.FILLER) {\n            return null;\n        } else if (detectedType === Terminal.STATEMENTS_FILLER) {\n            return null;\n        } else if (detectedType === NonTerminal.CLASSES) {\n            return this.createClassesNode(range, nodeCreationInformation);\n        } else if (detectedType === NonTerminal.FUNCTIONS) {\n            return this.createFunctionsNode(range, nodeCreationInformation);\n        } else if (detectedType === NonTerminal.FUNCTION_BODY) {\n            return null;\n        } else if (detectedType === NonTerminal.FUNCTION_DECLARATION) {\n            return this.createFunctionDeclarationNode(range, nodeCreationInformation);\n        } else {\n            throw Error(\"Invalid detected type! Should not have happened.\");\n        }\n    }\n\n    /**\n     * Validate the parsing state.\n     * @param state \n     */\n    private validateParsingStateTopLevel(\n        state: (Terminal | NonTerminal)[]\n    ) {\n        // top level has no restrictions except that the elements on the RHS of the production rule must be of some specified subset\n        for (const elem of state) {\n            if((elem !== Terminal.COMMENT_MULTILINE) && (elem !== Terminal.COMMENT_SINGLELINE) &&\n                (elem !== Terminal.FILLER) && (elem !== Terminal.REFERENCES) &&\n                (elem !== Terminal.STATEMENTS_FILLER) && (elem !== NonTerminal.CLASSES) &&\n                (elem !== NonTerminal.FUNCTIONS)) {\n                throw new CodeParserImplError(\"Apart from the filler types, top level code can only contain comments, references (imports), classes and functions!\");\n            }\n        }\n    }\n\n    /**\n     * Validate the parsing state.\n     * @param state \n     */\n    private validateParsingStateClasses(\n        state: (Terminal | NonTerminal)[]\n    ) {\n        // classes has no restrictions except that the elements on the RHS of the production rule must be of some specified subset\n        for (const elem of state) {\n            if((elem !== Terminal.COMMENT_MULTILINE) && (elem !== Terminal.COMMENT_SINGLELINE) && (elem !== Terminal.STATEMENTS_FILLER) &&\n                (elem !== Terminal.FILLER) && (elem !== Terminal.ATTRIBUTES) && (elem !== NonTerminal.FUNCTIONS)) {\n                throw new CodeParserImplError(\"Apart from the filler types, class code can only contain comments, attributes (member variables), and functions!\");\n            }\n        }\n    }\n\n    /**\n     * Validate the parsing state.\n     * @param state \n     */\n    private validateParsingStateFunctions(\n        state: (Terminal | NonTerminal)[]\n    ) {\n        if (state.length < 2) {\n            throw new CodeParserImplError(\"A valid function must contain a function declaration first and then function body afterwards! Therefore expected state length >= 2\");\n        }\n\n        const results = this.getFirstLast(state);\n        let first: Terminal | NonTerminal = results.first === -1 ? Terminal.FILLER : state[results.first];\n        let last: Terminal | NonTerminal = results.last === -1 ? Terminal.FILLER : state[results.last];\n\n        if (first !== NonTerminal.FUNCTION_DECLARATION || last !== NonTerminal.FUNCTION_BODY) {\n            throw new CodeParserImplError(\"A valid function must contain a function declaration first and then function body afterwards!\");\n        }\n    }\n\n    private getFirstLast(state: (Terminal | NonTerminal)[]): {first: number, last: number} {\n        let first: number = -1;\n        let last: number = -1;\n        \n        for (let i = 0; i < state.length; i++) {\n            const s = state[i];\n            if (s !== Terminal.FILLER && s !== Terminal.STATEMENTS_FILLER) {\n                first = i;\n                break;\n            }\n        }\n        for (let i = state.length - 1; i >= 0; i--) {\n            const s = state[i];\n            if (s !== Terminal.FILLER && s !== Terminal.STATEMENTS_FILLER) {\n                last = i;\n                break;\n            }\n        }\n\n        return {first, last};\n    }\n\n    /**\n     * Validate the parsing state.\n     * @param state \n     */\n    private validateParsingStateFunctionBody(\n        state: (Terminal | NonTerminal)[]\n    ) {\n        for (const elem of state) {\n            // function bodies has no restrictions except that the elements on the RHS of the production rule must be of some specified subset\n            if((elem !== Terminal.COMMENT_MULTILINE) && (elem !== Terminal.COMMENT_SINGLELINE) &&\n                (elem !== Terminal.FILLER) && (elem !== Terminal.STATEMENTS_FILLER)) {\n                throw new CodeParserImplError(\"Apart from the filler types, function body code can only contain comments!\");\n            }\n        }\n    }\n\n    /**\n     * Validate the parsing state.\n     * @param state \n     */\n    private validateParsingStateFunctionDeclaration(\n        state: (Terminal | NonTerminal)[]\n    ) {\n        // function declarations has no restrictions except that the elements on the RHS of the production rule must be of some specified subset\n        for (const elem of state) {\n            if (elem === Terminal.STATEMENTS_FILLER) {\n                throw new CodeParserImplError(\"Cannot have statements filler in function declarations! Code statements cannot be inside declarations.\");\n            }\n            if((elem !== Terminal.COMMENT_MULTILINE) && (elem !== Terminal.COMMENT_SINGLELINE) &&\n                (elem !== Terminal.FILLER) && (elem !== Terminal.ARGUMENT)) {\n                throw new CodeParserImplError(\"Apart from the filler types, function body code can only contain comments!\");\n            }\n        }\n    }\n\n    /**\n     * Creates an Argument node based on the previous nodeCreationInformation supplied as the return value of detectXXXSymbol functions.\n     * @param range \n     * @param nodeCreationInformation \n     */\n    protected abstract createArgumentNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): Argument;\n\n    /**\n     * Creates an Attributes node based on the previous nodeCreationInformation supplied as the return value of detectXXXSymbol functions.\n     * @param range \n     * @param nodeCreationInformation \n     */\n    protected abstract createAttributesNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): Attributes;\n\n    /**\n     * Creates an Comments node based on the previous nodeCreationInformation supplied as the return value of detectXXXSymbol functions.\n     * @param range \n     * @param nodeCreationInformation \n     */\n    protected abstract createCommentsNode(range: Range, isMultiLine: boolean, nodeCreationInformation: Record<string, any> | undefined): Comments;\n\n    /**\n     * Creates an References node based on the previous nodeCreationInformation supplied as the return value of detectXXXSymbol functions.\n     * @param range \n     * @param nodeCreationInformation \n     */\n    protected abstract createReferencesNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): References;\n\n    /**\n     * Creates an Classes node based on the previous nodeCreationInformation supplied as the return value of detectXXXSymbol functions.\n     * @param range \n     * @param nodeCreationInformation \n     */\n    protected abstract createClassesNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): Classes;\n\n    /**\n     * Creates an Functions node based on the previous nodeCreationInformation supplied as the return value of detectXXXSymbol functions.\n     * @param range \n     * @param nodeCreationInformation \n     */\n    protected abstract createFunctionsNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): Functions;\n\n    /**\n     * Creates an FunctionDeclaration node based on the previous nodeCreationInformation supplied as the return value of detectXXXSymbol functions.\n     * @param range \n     * @param nodeCreationInformation \n     */\n    protected abstract createFunctionDeclarationNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): FunctionDeclaration;\n\n\n    /**\n     * Resets the states of the internal detection, to parse a new non-terminal.\n     * @param The start of the detection index (inclusive), corresponding to the value in the first call of the detectXXXSymbol.\n     * @param The non-terminal that is to be parsed.\n     */\n    protected abstract resetDetectionState(startTokIndex: number, parsingNonTerminal: NonTerminal): void;\n\n    /**\n     * Returns whether comments for functions are placed before or after the function.\n     */\n    protected abstract isCommentBeforeFunction(): boolean;\n\n    /**\n     * Detects a symbol based on the current non-terminal, range, character, and depth.\n     * Must be implemented by subclasses.\n     * @param state The current state (production rule) that is being matched\n     * @param token The current token being inspected, or null if the end is reached.\n     * @param currentTokIndex The index of the current character in terms of the flattened string.\n     * @param depth The current depth in the parsing tree.\n     * @returns A SymbolAdditionDirective, or null if no symbols are detected.\n     * @throws CodeParsingError if there is an error during the code parsing and the API implementation has detected it.\n     */\n    protected abstract detectTopLevelSymbol(\n        state: (Terminal | NonTerminal)[],\n        token: Token | null,\n        currentTokIndex: number,\n        depth: number\n    ): SymbolAdditionDirective | null;\n\n    /**\n     * Detects a symbol based on the current non-terminal, range, character, and depth.\n     * Must be implemented by subclasses.\n     * @param state The current state (production rule) that is being matched\n     * @param token The current token being inspected, or null if the end is reached.\n     * @param currentTokIndex The index of the current character in terms of the flattened string.\n     * @param depth The current depth in the parsing tree.\n     * @returns A SymbolAdditionDirective, or null if no symbols are detected.\n     * @throws CodeParsingError if there is an error during the code parsing and the API implementation has detected it.\n     */\n    protected abstract detectClassesSymbol(\n        state: (Terminal | NonTerminal)[],\n        token: Token | null,\n        currentTokIndex: number,\n        depth: number\n    ): SymbolAdditionDirective | null;\n\n    /**\n     * Detects a symbol based on the current non-terminal, range, character, and depth.\n     * Must be implemented by subclasses.\n     * @param state The current state (production rule) that is being matched\n     * @param token The current token being inspected, or null if the end is reached.\n     * @param currentTokIndex The index of the current character in terms of the flattened string.\n     * @param depth The current depth in the parsing tree.\n     * @returns A SymbolAdditionDirective, or null if no symbols are detected.\n     * @throws CodeParsingError if there is an error during the code parsing and the API implementation has detected it.\n     */\n    protected abstract detectFunctionsSymbol(\n        state: (Terminal | NonTerminal)[],\n        token: Token | null,\n        currentTokIndex: number,\n        depth: number\n    ): SymbolAdditionDirective | null;\n\n    /**\n     * Detects a symbol based on the current non-terminal, range, character, and depth.\n     * Must be implemented by subclasses.\n     * @param state The current state (production rule) that is being matched\n     * @param token The current token being inspected, or null if the end is reached.\n     * @param currentTokIndex The index of the current character in terms of the flattened string.\n     * @param depth The current depth in the parsing tree.\n     * @returns A SymbolAdditionDirective, or null if no symbols are detected.\n     * @throws CodeParsingError if there is an error during the code parsing and the API implementation has detected it.\n     */\n    protected abstract detectFunctionBodySymbol(\n        state: (Terminal | NonTerminal)[],\n        token: Token | null,\n        currentTokIndex: number,\n        depth: number\n    ): SymbolAdditionDirective | null;\n\n    /**\n     * Detects a symbol based on the current non-terminal, range, character, and depth.\n     * Must be implemented by subclasses.\n     * @param state The current state (production rule) that is being matched\n     * @param token The current token being inspected, or null if the end is reached.\n     * @param currentTokIndex The index of the current character in terms of the flattened string.\n     * @param depth The current depth in the parsing tree.\n     * @returns A SymbolAdditionDirective, or null if no symbols are detected.\n     * @throws CodeParsingError if there is an error during the code parsing and the API implementation has detected it.\n     */\n    protected abstract detectFunctionDeclarationSymbol(\n        state: (Terminal | NonTerminal)[],\n        token: Token | null,\n        currentTokIndex: number,\n        depth: number\n    ): SymbolAdditionDirective | null;\n}\n","import { Attributes, Classes, Comments, FunctionGroups, Functions, References, SyntaxNode } from \"../../nodes\";\nimport { ASTGenericTokenizer, TextRange, TokenAction, TreeToken, TreeTokenType } from \"../../parsing/ASTGenericTokenizer\";\n\nexport class PythonSimplificationTokenizer extends ASTGenericTokenizer {\n    private indentation: string;\n\n    constructor(indentation?: string) {\n        super();\n        if (indentation === undefined) {\n            this.indentation = \"    \";\n        } else {\n            this.indentation = indentation;\n        }\n    }\n\n    protected pretokenize(tokenString: TreeToken[]): void {}\n    protected posttokenize(tokenString: TreeToken[]): void {}\n    protected convertIntoTokens(node: SyntaxNode, depth: number, previousNode: SyntaxNode | null, tokenText: TextRange, tokenPrefixText: TextRange | null, tokenSuffixText: TextRange | null): { prefixTokens?: TreeToken[]; suffixTokens?: TreeToken[]; action: TokenAction; } {\n        if (depth === 0) {\n            // no need to add anything, simply resolve\n            return {action: TokenAction.RESOLVE};\n        }\n        const stringEnder: string = \"\\n\" + this.indentation.repeat(depth - 1);\n\n        // translate the current node to tokens\n        if (node instanceof References) {\n            return {prefixTokens: [\n                {stringContents: tokenText.text, range: tokenText.range, tokenType: TreeTokenType.REFERENCES, originalNode: node},\n                {stringContents: stringEnder, tokenType: TreeTokenType.OTHERS}\n            ], action: TokenAction.TERMINATE};\n        } else if (node instanceof Comments) {\n            return {prefixTokens: [\n                {stringContents: tokenText.text, range: tokenText.range, tokenType: TreeTokenType.COMMENTS, originalNode: node},\n                {stringContents: stringEnder, tokenType: TreeTokenType.OTHERS}\n            ], action: TokenAction.TERMINATE};\n        } else if (node instanceof Classes) {\n            // see if theres contents. if not, add a pass\n            if (tokenPrefixText !== null) {\n                if (node.listChildren().length === 0) {\n                    const bodyContents: string = this.needsFillTokens() ? (stringEnder + this.indentation + \"pass\" + stringEnder) : (stringEnder + this.indentation);\n                    return {\n                        prefixTokens: [\n                            {stringContents: tokenPrefixText.text, range: tokenPrefixText.range, tokenType: TreeTokenType.CLASS, originalNode: node},\n                            {stringContents: bodyContents, tokenType: TreeTokenType.OTHERS}\n                        ],\n                        action: TokenAction.RESOLVE\n                    };\n                } else {\n                    return {\n                        prefixTokens: [\n                            {stringContents: tokenPrefixText.text, range: tokenPrefixText.range, tokenType: TreeTokenType.CLASS, originalNode: node},\n                            {stringContents: stringEnder + this.indentation, tokenType: TreeTokenType.OTHERS}\n                        ],\n                        suffixTokens: [\n                            {stringContents: stringEnder, tokenType: TreeTokenType.OTHERS}\n                        ],\n                        action: TokenAction.RESOLVE\n                    };\n                }\n            } else {\n                throw Error(\"Unexpected null!\");\n            }\n            \n        } else if (node instanceof Attributes) {\n            return {prefixTokens: [\n                {stringContents: tokenText.text, range: tokenText.range, tokenType: TreeTokenType.ATTRIBUTE, originalNode: node},\n                {stringContents: stringEnder, tokenType: TreeTokenType.OTHERS}\n            ], action: TokenAction.TERMINATE};\n        } else if (node instanceof FunctionGroups) {\n            if (node.hasComment()) {\n                const children: SyntaxNode[] = node.listChildren();\n                if (children.length !== 2) {\n                    throw Error(\"Expected 2 children for a function group with comments!\");\n                }\n                if (!(children[0] instanceof Functions)) {\n                    throw Error(\"Expected first child of function group to be a Function!\");\n                }\n                if (!(children[1] instanceof Comments)) {\n                    throw Error(\"Expected second child of function group to be a comment!\");\n                }\n\n                // add function and comment\n                const func: Functions = children[0];\n                const comment: Comments = children[1];\n                const funcTexts = this.getTexts(func);\n                const commentTexts = this.getTexts(comment);\n                return {\n                    prefixTokens: [\n                        {stringContents: funcTexts.tokenPrefixText!.text, range: funcTexts.tokenPrefixText!.range, tokenType: TreeTokenType.FUNCTION, originalNode: func},\n                        {stringContents: stringEnder + this.indentation, tokenType: TreeTokenType.OTHERS},\n                        {stringContents: commentTexts.tokenText.text, range: commentTexts.tokenText.range, tokenType: TreeTokenType.COMMENTS, originalNode: comment},\n                        {stringContents: stringEnder, tokenType: TreeTokenType.OTHERS}\n                    ],\n                    action: TokenAction.TERMINATE\n                };\n            } else {\n                const children: SyntaxNode[] = node.listChildren();\n                if (children.length !== 1) {\n                    throw Error(\"Expected 1 child for a function group without comments!\");\n                }\n                if (!(children[0] instanceof Functions)) {\n                    throw Error(\"Expected first child of function group to be a Function!\");\n                }\n\n                // add function and pass\n                const func: Functions = children[0];\n                const funcTexts = this.getTexts(func);\n                const bodyContents: string = this.needsFillTokens() ? (stringEnder + this.indentation + \"pass\" + stringEnder) : (stringEnder + this.indentation);\n                return {\n                    prefixTokens: [\n                        {stringContents: funcTexts.tokenPrefixText!.text, range: funcTexts.tokenPrefixText!.range, tokenType: TreeTokenType.FUNCTION, originalNode: func},\n                        {stringContents: bodyContents, tokenType: TreeTokenType.OTHERS},\n                    ],\n                    action: TokenAction.TERMINATE\n                };\n            }\n        }\n\n        throw Error(\"Some scenarios not explored!\");\n    }\n\n    protected includeIndentation(tokenString: TreeToken[], depth: number): void {\n        // push indentation\n        tokenString.push({stringContents: this.indentation.repeat(depth - 1), tokenType: TreeTokenType.OTHERS});\n    }\n}","import { Attributes, Classes, Comments, FunctionGroups, Functions, References, SyntaxNode } from \"../../nodes\";\nimport { ASTGenericTokenizer, TextRange, TokenAction, TreeToken, TreeTokenType } from \"../../parsing/ASTGenericTokenizer\";\n\nexport class TypeScriptSimplificationTokenizer extends ASTGenericTokenizer {\n    private indentation: string;\n\n    constructor(indentation?: string) {\n        super();\n        if (indentation === undefined) {\n            this.indentation = \"    \";\n        } else {\n            this.indentation = indentation;\n        }\n    }\n\n    protected pretokenize(tokenString: TreeToken[]): void {}\n    protected posttokenize(tokenString: TreeToken[]): void {}\n    protected convertIntoTokens(node: SyntaxNode, depth: number, previousNode: SyntaxNode | null, tokenText: TextRange, tokenPrefixText: TextRange | null, tokenSuffixText: TextRange | null): { prefixTokens?: TreeToken[]; suffixTokens?: TreeToken[]; action: TokenAction; } {\n        if (depth === 0) {\n            // no need to add anything, simply resolve\n            return {action: TokenAction.RESOLVE};\n        }\n        const stringEnder: string = \"\\n\" + this.indentation.repeat(depth - 1);\n\n        // translate the current node to tokens\n        if (node instanceof References) {\n            return {prefixTokens: [\n                {stringContents: tokenText.text, range: tokenText.range, tokenType: TreeTokenType.REFERENCES, originalNode: node},\n                {stringContents: \";\" + stringEnder, tokenType: TreeTokenType.OTHERS}\n            ], action: TokenAction.TERMINATE};\n        } else if (node instanceof Comments) {\n            return {prefixTokens: [\n                {stringContents: tokenText.text, range: tokenText.range, tokenType: TreeTokenType.COMMENTS, originalNode: node},\n                {stringContents: stringEnder, tokenType: TreeTokenType.OTHERS}\n            ], action: TokenAction.TERMINATE};\n        } else if (node instanceof Classes) {\n            return {\n                prefixTokens: [\n                    {stringContents: tokenPrefixText!.text, range: tokenPrefixText!.range, tokenType: TreeTokenType.CLASS, originalNode: node},\n                    {stringContents: stringEnder + this.indentation, tokenType: TreeTokenType.OTHERS},\n                ],\n                suffixTokens: [\n                    {stringContents: stringEnder, tokenType: TreeTokenType.OTHERS},\n                    {stringContents: tokenSuffixText!.text, range: tokenSuffixText!.range, tokenType: TreeTokenType.CLASS, originalNode: node},\n                    {stringContents: stringEnder, tokenType: TreeTokenType.OTHERS}\n                ],\n                action: TokenAction.RESOLVE\n            };\n        } else if (node instanceof Attributes) {\n            return {prefixTokens: [\n                {stringContents: tokenText.text, range: tokenText.range, tokenType: TreeTokenType.ATTRIBUTE, originalNode: node},\n                {stringContents: \";\" + stringEnder, tokenType: TreeTokenType.OTHERS}\n            ], action: TokenAction.TERMINATE};\n        } else if (node instanceof FunctionGroups) {\n            if (node.hasComment()) {\n                const children: SyntaxNode[] = node.listChildren();\n                if (children.length !== 2) {\n                    throw Error(\"Expected 2 children for a function group with comments!\");\n                }\n                if (!(children[0] instanceof Comments)) {\n                    throw Error(\"Expected first child of function group to be a comment!\");\n                }\n                if (!(children[1] instanceof Functions)) {\n                    throw Error(\"Expected second child of function group to be a Function!\");\n                }\n\n                // add function and comment\n                const comment: Comments = children[0];\n                const func: Functions = children[1];\n                const commentTexts = this.getTexts(comment);\n                const funcTexts = this.getTexts(func);\n                return {\n                    prefixTokens: [\n                        {stringContents: commentTexts.tokenText.text, range: commentTexts.tokenText.range, tokenType: TreeTokenType.COMMENTS, originalNode: comment},\n                        {stringContents: stringEnder, tokenType: TreeTokenType.OTHERS},\n                        {stringContents: funcTexts.tokenPrefixText!.text, range: funcTexts.tokenPrefixText!.range, tokenType: TreeTokenType.FUNCTION, originalNode: func},\n                        {stringContents: funcTexts.tokenSuffixText!.text, range: funcTexts.tokenSuffixText!.range, tokenType: TreeTokenType.FUNCTION, originalNode: func},\n                        {stringContents: stringEnder, tokenType: TreeTokenType.OTHERS}\n                    ],\n                    action: TokenAction.TERMINATE\n                };\n            } else {\n                const children: SyntaxNode[] = node.listChildren();\n                if (children.length !== 1) {\n                    throw Error(\"Expected 1 child for a function group without comments!\");\n                }\n                if (!(children[0] instanceof Functions)) {\n                    throw Error(\"Expected first child of function group to be a Function!\");\n                }\n\n                // add function and pass\n                const func: Functions = children[0];\n                const funcTexts = this.getTexts(func);\n                return {\n                    prefixTokens: [\n                        {stringContents: funcTexts.tokenPrefixText!.text, range: funcTexts.tokenPrefixText!.range, tokenType: TreeTokenType.FUNCTION, originalNode: func},\n                        {stringContents: funcTexts.tokenSuffixText!.text, range: funcTexts.tokenSuffixText!.range, tokenType: TreeTokenType.FUNCTION, originalNode: func},\n                        {stringContents: stringEnder, tokenType: TreeTokenType.OTHERS}\n                    ],\n                    action: TokenAction.TERMINATE\n                };\n            }\n        }\n\n        throw Error(\"Some scenarios not explored!\");\n    }\n\n    protected includeIndentation(tokenString: TreeToken[], depth: number): void {\n        // push indentation\n        tokenString.push({stringContents: this.indentation.repeat(depth - 1), tokenType: TreeTokenType.OTHERS});\n    }\n}","import { TreeToken } from \"../parsing/ASTGenericTokenizer\";\nimport { ASTFaithfulTokenizer, TokenizationMode } from \"../parsing/ASTFaithfulTokenizer\";\nimport { AbstractSyntaxTree } from \"../parsing/AbstractSyntaxTree\";\nimport { PythonSimplificationTokenizer } from \"../impl/python/PythonSimplificationTokenizer\";\nimport { TypeScriptSimplificationTokenizer } from \"../impl/typescript/TypeScriptSimplificationTokenizer\";\n\nexport function flattenFaithfully(\n    tree: AbstractSyntaxTree,\n    mode: TokenizationMode,\n    excludeInnerRangeIfPossible: boolean\n): TreeToken[] {\n    const tokenizer = new ASTFaithfulTokenizer(mode, excludeInnerRangeIfPossible);\n    return tokenizer.tokenize(tree);\n}\n\nexport function flattenPython(\n    tree: AbstractSyntaxTree,\n    indentation?: string\n):  TreeToken[] {\n    const tokenizer = new PythonSimplificationTokenizer(indentation);\n    return tokenizer.tokenize(tree);\n}\n\nexport function flattenTypeScript(\n    tree: AbstractSyntaxTree,\n    indentation?: string\n): TreeToken[] {\n    const tokenizer = new TypeScriptSimplificationTokenizer(indentation);\n    return tokenizer.tokenize(tree);\n}\n\nexport { TokenizationMode };","import { BracesMatcher } from \"../../matchers/BracesMatcher\";\nimport { Token } from \"../../parsing/ParsingTypes\";\n\nconst typeBraces = [\n    { opening: '(', closing: ')' },\n    { opening: '{', closing: '}' },\n    { opening: '[', closing: ']' },\n    { opening: '<', closing: '>' },\n];\n\nconst assignmentBraces = [\n    { opening: '(', closing: ')' },\n    { opening: '{', closing: '}' },\n    { opening: '[', closing: ']' }\n];\n\nfunction isOpeningBraceType(tok: Token): boolean {\n    return typeBraces.some(x => x.opening === tok.stringContents);\n}\n\nfunction isClosingBraceType(tok: Token): boolean {\n    return typeBraces.some(x => x.closing === tok.stringContents);\n}\n\nfunction isOpeningBraceAssignment(tok: Token): boolean {\n    return assignmentBraces.some(x => x.opening === tok.stringContents);\n}\n\nfunction isClosingBraceAssignment(tok: Token): boolean {\n    return assignmentBraces.some(x => x.closing === tok.stringContents);\n}\n\nenum State {\n    READING_NAME,\n    READING_TYPE,\n    READING_ASSIGNMENT\n}\n\nexport class TypeScriptVarDeclMatcher {\n    private state: State;\n    private nameBuffer: string | null;\n    private typeBuffer: string | null;\n    private assignmentBuffer: string | null;\n    private typeBracesMatcher: BracesMatcher;\n    private assignmentBracesMatcher: BracesMatcher;\n\n    constructor() {\n        this.typeBracesMatcher = new BracesMatcher(typeBraces);\n        this.assignmentBracesMatcher = new BracesMatcher(assignmentBraces);\n\n        // default values\n        this.state = State.READING_NAME;\n        this.nameBuffer = \"\";\n        this.typeBuffer = null;\n        this.assignmentBuffer = null;\n    }\n\n    /**\n     * Processes the next token in the stream.\n     * @param tok - The next token to process.\n     * @returns An object with name type and assignment if parsing is complete, otherwise null.\n     */\n    public next(tok: Token): {name: string, type: string | null, assignment: string | null} | null {\n        switch (this.state) {\n            case State.READING_NAME:\n                return this.handleReadingName(tok);\n            case State.READING_TYPE:\n                return this.handleReadingType(tok);\n            case State.READING_ASSIGNMENT:\n                return this.handleReadingAssignment(tok);\n            default:\n                // Invalid state, reset parser\n                this.reset();\n                return null;\n        }\n    }\n\n    /**\n     * Resets the internal state of the TypeScriptVarDeclMatcher. Returns the current contents if exists\n     */\n    public reset(): {name: string, type: string | null, assignment: string | null} | null {\n        let retValue: {name: string, type: string | null, assignment: string | null} | null;\n        if (this.nameBuffer === null || this.nameBuffer.trim().length === 0) {\n            retValue = null;\n        } else {\n            retValue = {\n                name: this.nameBuffer.trim(),\n                type: this.typeBuffer === null ? null : this.typeBuffer.trim(),\n                assignment: this.assignmentBuffer === null ? null : this.assignmentBuffer.trim()\n            };\n        }\n\n        this.state = State.READING_NAME;\n        this.nameBuffer = null;\n        this.typeBuffer = null;\n        this.assignmentBuffer = null;\n        this.typeBracesMatcher.reset();\n        this.assignmentBracesMatcher.reset();\n\n        return retValue;\n    }\n    \n    private handleReadingName(tok: Token): {name: string, type: string | null, assignment: string | null} | null {\n        if ([\":\", \"=\", \";\", \",\", \")\"].includes(tok.stringContents)) {\n            switch (tok.stringContents) {\n                case \":\":\n                    this.state = State.READING_TYPE; // read the type\n                    return null;\n                case \"=\":\n                    this.state = State.READING_ASSIGNMENT; // direct assignmnet\n                    return null;\n                case \";\": // stopped\n                case \",\":\n                case \")\":\n                    return this.reset();\n                default:\n                    throw Error(\"Shouldn't have happened!\");\n            }\n        } else {\n            if (this.nameBuffer !== null) {\n                this.nameBuffer += tok.stringContents;\n            } else {\n                this.nameBuffer = tok.stringContents;\n            }\n            return null;\n        }\n    }\n\n    private handleReadingType(tok: Token): {name: string, type: string | null, assignment: string | null} | null {\n        if ([\"=\", \";\", \",\", \")\"].includes(tok.stringContents) && this.typeBracesMatcher.currentDepth() === 0) {\n            switch (tok.stringContents) {\n                case \"=\":\n                    this.state = State.READING_ASSIGNMENT;\n                    return null;\n                case \";\":\n                case \",\":\n                case \")\":\n                    return this.reset();\n            }\n        }\n\n        if (this.typeBuffer === null) {\n            this.typeBuffer = tok.stringContents;\n        } else {\n            this.typeBuffer += tok.stringContents;\n        }\n\n        if (isOpeningBraceType(tok) || isClosingBraceType(tok)) {\n            this.typeBracesMatcher.next(tok.stringContents);\n        }\n        return null;\n    }\n\n    private handleReadingAssignment(tok: Token): {name: string, type: string | null, assignment: string | null} | null {\n        if ([\";\", \",\", \")\"].includes(tok.stringContents) && this.assignmentBracesMatcher.currentDepth() === 0) {\n            return this.reset();\n        }\n\n        if (this.assignmentBuffer === null) {\n            this.assignmentBuffer = tok.stringContents;\n        } else {\n            this.assignmentBuffer += tok.stringContents;\n        }\n        if (isOpeningBraceAssignment(tok) || isClosingBraceAssignment(tok)) {\n            this.assignmentBracesMatcher.next(tok.stringContents);\n        }\n        return null;\n    }\n}","import { Token, NonTerminal, Terminal, SymbolAdditionDirective, SymbolInfo, TokenType, TokenRange } from \"../../parsing/ParsingTypes\";\nimport { CodeParsingError } from \"../../CodeParsingError\";\nimport { Range } from \"../../utils\";\nimport { BracesMatcher } from \"../../matchers/BracesMatcher\";\nimport { AbstractParser } from \"../../parsing/AbstractParser\";\nimport { Argument, Attributes, Classes, Comments, FunctionDeclaration, Functions, References } from \"../../nodes\";\nimport { AbstractTokenizer } from \"../../parsing/AbstractTokenizer\";\nimport { TypeScriptTokenizer } from \"./TypeScriptTokenizer\";\nimport { TypeScriptVarDeclMatcher } from \"./TypeScriptVarDeclMatcher\";\n\nenum SpecialTokens {\n    FUNCTION_KEYWORD,\n    CLASS_KEYWORD,\n    ANY_KEYWORD,\n    OPENING_BRACKET,\n    CLOSING_BRACKET,\n    OPENING_BRACE,\n    CLOSING_BRACE,\n    COLON\n}\n\n/**\n * TypeScriptParser class is responsible for parsing Python source code into a tree structure.\n */\nexport class TypeScriptParser extends AbstractParser {\n    private bracesMatcher: BracesMatcher;\n    private curlyBracesMatcher: BracesMatcher;\n    private argumentMatcher: TypeScriptVarDeclMatcher;\n\n    /**\n     * Initializes a new instance of the PythonParser class.\n     */\n    constructor() {\n        super();\n\n        this.parseType = NonTerminal.TOP_LEVEL;\n        this.bracesMatcher = new BracesMatcher([\n            {opening: \"{\", closing: \"}\"},\n            {opening: \"[\", closing: \"]\"},\n            {opening: \"(\", closing: \")\"}\n        ]);\n        this.curlyBracesMatcher = new BracesMatcher([\n            {opening: \"{\", closing: \"}\"}\n        ]);\n        this.argumentMatcher = new TypeScriptVarDeclMatcher();\n        this.globalDetectionStartIndex = -1;\n        this.mostRecentStatementsEndTokIdx = -1;\n        this.continuousSpacingsAfterTerminateStatements = true;\n\n\n        this.functOpeningBracket = -1;\n        this.functClosingBracket = -1;\n        this.functOpeningBrace = -1;\n        this.functClosingBrace = -1;\n        this.functRetTypeBracesMatcher = new BracesMatcher([\n            {opening: \"{\", closing: \"}\"},\n            {opening: \"[\", closing: \"]\"},\n            {opening: \"(\", closing: \")\"},\n            {opening: \"<\", closing: \">\"}\n        ]);\n        this.functName = \"\";\n        this.functType = null;\n        this.functPreviousImmediatelyColon = false;\n        this.functPreviousImmediatelyClosingBracket = false;\n\n        this.functBodyHasOthers = false;\n        this.functBodyHasPreviousContent = false;\n\n        this.functDeclStartParseIdx = -1;\n        this.functDeclParsing = false;\n\n        this.codeBlocksHasComments = false;\n        this.codeBlocksSymbolToDetect = Terminal.STATEMENTS_FILLER;\n        this.codeBlocksLastSymbolDetectionEnd = -1;\n        this.codeBlocksHasContents = false;\n        this.codeBlocksStartOfPotentialDetection = -1;\n\n        this.cbSymbSpacesTextsOnly = true;\n        this.cbSymbAttemptedDetect = false;\n        this.cbSymbStringStream = \"\";\n        this.cbSymbTokenStream = [];\n\n        this.cbSymbClassOpeningBrace = -1;\n        this.cbSymbClassClosingBrace = -1;\n        this.cbSymbClassDefnText = null;\n\n        this.cbSymbFuncOpeningBracket = -1;\n        this.cbSymbFuncClosingBracket = -1;\n        this.cbSymbFuncOpeningBrace = -1;\n        this.cbSymbFuncClosingBrace = -1;\n        this.cbSymbFuncDefnText = null;\n        this.cbSymbFuncPreviousImmediatelyColon = false;\n        this.cbSymbFuncRetTypeBracesMatcher = new BracesMatcher([\n            {opening: \"{\", closing: \"}\"},\n            {opening: \"[\", closing: \"]\"},\n            {opening: \"(\", closing: \")\"},\n            {opening: \"<\", closing: \">\"}\n        ]);\n\n        // Initialize various states\n        this.resetDetectionState(0, NonTerminal.TOP_LEVEL);\n    }\n\n    protected preparse(codeLines: string[], tokens: Token[]): void {\n        \n    }\n\n    /**\n     * Returns whether comments for functions are placed before or after the function.\n     * For TypeScript, comments are typically placed before the function.\n     */\n    protected isCommentBeforeFunction(): boolean {\n        return true;\n    }\n\n    /**\n     * We use PythonTokenizer\n     * @returns A new PythonTokenizer\n     */\n    protected preparseGetTokenizer(): AbstractTokenizer {\n        return new TypeScriptTokenizer();\n    }\n\n\n    protected createArgumentNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): Argument {\n        return new Argument(range, nodeCreationInformation!.argumentName!, nodeCreationInformation!.argumentType);\n    }\n    protected createAttributesNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): Attributes {\n        return new Attributes(range, nodeCreationInformation!.attributeName!, nodeCreationInformation!.attributeType);\n    }\n    protected createCommentsNode(range: Range, isMultiLine: boolean, nodeCreationInformation: Record<string, any> | undefined): Comments {\n        return new Comments(range, isMultiLine, nodeCreationInformation!.commentContents!);\n    }\n    protected createReferencesNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): References {\n        return new References(range, nodeCreationInformation!.referenceText!, nodeCreationInformation!.refRelativePath);\n    }\n    protected createClassesNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): Classes {\n        // better to include the inner range, so that it is possible to extract more precisely the minimal \"keywords\" used to match the class\n        const node = new Classes(range, nodeCreationInformation!.classType, nodeCreationInformation!.classDefinitionText!);\n        node.overrideInnerRange(nodeCreationInformation!.classInnerRange!);\n        return node;\n    }\n    protected createFunctionsNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): Functions {\n        // better to include the inner range, so that it is possible to extract more precisely the minimal \"keywords\" used to match the function\n        const node = new Functions(range, nodeCreationInformation!.functionDefinitionText!);\n        node.overrideInnerRange(nodeCreationInformation!.funcInnerRange!);\n        return node;\n    }\n    protected createFunctionDeclarationNode(range: Range, nodeCreationInformation: Record<string, any> | undefined): FunctionDeclaration {\n        return new FunctionDeclaration(range, nodeCreationInformation!.functionName!, nodeCreationInformation!.functionReturnType);\n    }\n\n    // global indicator states\n    private parseType: NonTerminal;\n    private globalDetectionStartIndex: number;\n    private mostRecentStatementsEndTokIdx: number; // the token which serves as the most recent statement end. its equal to globalDetectionStartIndex - 1 initially (since initially there aren't any statement ends)\n    private continuousSpacingsAfterTerminateStatements: boolean; // whether we have continuously met spacings after the end of the statements\n\n    protected resetDetectionState(startTokIndex: number, parsingNonTerminal: NonTerminal): void {\n        this.globalDetectionStartIndex = startTokIndex;\n        this.parseType = parsingNonTerminal;\n        this.bracesMatcher.reset();\n        this.curlyBracesMatcher.reset();\n        this.argumentMatcher.reset();\n        this.mostRecentStatementsEndTokIdx = startTokIndex - 1;\n        this.continuousSpacingsAfterTerminateStatements = true;\n\n        if (parsingNonTerminal === NonTerminal.TOP_LEVEL) {\n            this.codeBlocksHasComments = false;\n            this.codeBlocksSymbolToDetect = Terminal.STATEMENTS_FILLER;\n            this.codeBlocksLastSymbolDetectionEnd = startTokIndex - 1; // inclusive\n            this.codeBlocksHasContents = false;\n            this.codeBlocksStartOfPotentialDetection = -1;\n        } else if (parsingNonTerminal === NonTerminal.CLASSES) {\n            this.codeBlocksHasComments = false;\n            this.codeBlocksSymbolToDetect = Terminal.STATEMENTS_FILLER;\n            this.codeBlocksLastSymbolDetectionEnd = startTokIndex - 1; // inclusive\n            this.codeBlocksHasContents = false;\n            this.codeBlocksStartOfPotentialDetection = -1;\n        } else if (parsingNonTerminal === NonTerminal.FUNCTIONS) {\n            this.functOpeningBracket = -1;\n            this.functClosingBracket = -1;\n            this.functOpeningBrace = -1;\n            this.functClosingBrace = -1;\n            this.functRetTypeBracesMatcher.reset();\n            this.functName = \"\";\n            this.functType = null;\n            this.functPreviousImmediatelyColon = false;\n            this.functPreviousImmediatelyClosingBracket = false;\n        } else if (parsingNonTerminal === NonTerminal.FUNCTION_BODY) {\n            this.functBodyHasOthers = false;\n            this.functBodyHasPreviousContent = false;\n        } else if (parsingNonTerminal === NonTerminal.FUNCTION_DECLARATION) {\n            this.functDeclStartParseIdx = -1;\n            this.functDeclParsing = false;\n        }\n    }\n\n    protected detectTopLevelSymbol(state: (Terminal | NonTerminal)[], token: Token | null, currentTokIndex: number, depth: number): SymbolAdditionDirective | null {\n        return this.detectCodeBlocks(token, currentTokIndex);\n    }\n\n    protected detectClassesSymbol(state: (Terminal | NonTerminal)[], token: Token | null, currentTokIndex: number, depth: number): SymbolAdditionDirective | null {\n        return this.detectCodeBlocks(token, currentTokIndex);\n    }\n\n    private functOpeningBracket: number;\n    private functClosingBracket: number;\n    private functOpeningBrace: number;\n    private functClosingBrace: number;\n    private functRetTypeBracesMatcher: BracesMatcher;\n    private functName: string;\n    private functType: string | null;\n    private functPreviousImmediatelyColon: boolean;\n    private functPreviousImmediatelyClosingBracket: boolean;\n    protected detectFunctionsSymbol(state: (Terminal | NonTerminal)[], token: Token | null, currentTokIndex: number, depth: number): SymbolAdditionDirective | null {\n        if (token === null) {\n            // final conclusion, the last is a function body with closing brace\n            return {\n                symbol: {symbolType: NonTerminal.FUNCTION_BODY},\n                secondSymbol: {symbolType: Terminal.FILLER},\n                secondSymbolLen: 1\n            };\n        }\n\n        let retValue: SymbolAdditionDirective | null = null;\n        // detect the opening and closing bracket pairs, and then the opening and closing braces\n        if (this.functOpeningBracket === -1) {\n            if (token.tokenType === TokenType.OTHERS) {\n                this.functName = token.stringContents; // function name is the token right before the opening bracket\n            }\n            if (token.stringContents === \"(\" && this.bracesMatcher.currentDepth() === 0) {\n                this.functOpeningBracket = currentTokIndex;\n            }\n        } else if (this.functClosingBracket === -1) {\n            if (token.stringContents === \")\" && this.bracesMatcher.currentDepth() === 1) {\n                this.functClosingBracket = currentTokIndex;\n                this.functPreviousImmediatelyClosingBracket = true;\n            }\n        } else if (this.functOpeningBrace === -1) {\n            // try to detect the opening brace\n            if (this.functRetTypeBracesMatcher.currentDepth() === 0 && !this.functPreviousImmediatelyColon && token.stringContents === \"{\") {\n                if (this.functType !== null) {\n                    this.functType = this.stripString(this.functType);\n                }\n                this.functOpeningBrace = currentTokIndex;\n                this.functRetTypeBracesMatcher.reset();\n\n                // function declaration detected, and parse range should not include the opening brace\n                // unlike Python, we do not include the opening brace at the end too\n                retValue = {symbol:  {\n                    symbolType: NonTerminal.FUNCTION_DECLARATION,\n                    parseRange: {startTok: this.globalDetectionStartIndex, endTok: this.functOpeningBrace}, // end tok is non inclusive on the right\n                    nodeCreationInformation: {functionName: this.functName.trim(), functionReturnType: this.functType}\n                }, secondSymbolLen: 1, secondSymbol: {symbolType: Terminal.FILLER}};\n            } else if (this.functPreviousImmediatelyColon && this.functRetTypeBracesMatcher.currentDepth() === 0) {\n                this.functType = token.stringContents; // start of detecting funct type\n            } else if (this.functType !== null) {\n                this.functType += token.stringContents;\n            }\n\n            if (token.tokenType == TokenType.BRACES || token.stringContents === \"<\" || token.stringContents === \">\") {\n                try {\n                    this.functRetTypeBracesMatcher.next(token.stringContents);\n                } catch (e: any) {\n                    if (e instanceof Error) {\n                        throw new CodeParsingError(\"Error during brace matching! \" + e.message);\n                    }\n                    throw e;\n                }\n            }\n        } else if (this.functClosingBrace === -1) {\n            // try to detect the closing brace\n            if (this.curlyBracesMatcher.currentDepth() === 1 && token.stringContents === \"}\") {\n                this.functClosingBrace = currentTokIndex;\n            }\n        }\n\n        if (token.stringContents === \":\") {\n            this.functPreviousImmediatelyColon = true;\n        } else if (token.tokenType !== TokenType.SPACINGS) {\n            this.functPreviousImmediatelyColon = false;\n        }\n        if (token.tokenType !== TokenType.SPACINGS) {\n            this.functPreviousImmediatelyClosingBracket = false;\n        }\n\n        this.updateBracesAndTerminateStatementsState(token, currentTokIndex);\n        return retValue;\n    }\n\n    private functBodyHasOthers: boolean;\n    private functBodyHasPreviousContent: boolean;\n    protected detectFunctionBodySymbol(state: (Terminal | NonTerminal)[], token: Token | null, currentTokIndex: number, depth: number): SymbolAdditionDirective | null {\n        // simply parse the comments and multiline comments, without caring about the indentation\n        if (token === null) {\n            if (this.functBodyHasPreviousContent) {\n                return {symbol: {symbolType: this.functBodyHasOthers ? Terminal.STATEMENTS_FILLER: Terminal.FILLER}};\n            }\n            return null;\n        }\n\n        let retDirective: SymbolAdditionDirective | null = null;\n        if (token.tokenType === TokenType.SINGLELINE_COMMENTS) {\n            if (this.functBodyHasPreviousContent) {\n                retDirective = {\n                    symbol: {symbolType: this.functBodyHasOthers ? Terminal.STATEMENTS_FILLER: Terminal.FILLER},\n                    secondSymbol: {symbolType: Terminal.COMMENT_SINGLELINE, nodeCreationInformation: {commentContents: token.stringContents.substring(2, token.stringContents.length)}}\n                }\n            } else {\n                retDirective = {symbol: {symbolType: Terminal.COMMENT_SINGLELINE, nodeCreationInformation: {commentContents: token.stringContents.substring(2, token.stringContents.length)}}};\n            }\n\n            // reset\n            this.functBodyHasOthers = false;\n            this.functBodyHasPreviousContent = false;\n        } else if (token.tokenType === TokenType.MULTILINE_COMMENTS_OR_STRINGS && token.stringContents.startsWith(\"/*\") && token.stringContents.endsWith(\"*/\")) {\n            if (this.functBodyHasPreviousContent) {\n                retDirective = {\n                    symbol: {symbolType: this.functBodyHasOthers ? Terminal.STATEMENTS_FILLER: Terminal.FILLER},\n                    secondSymbol: {symbolType: Terminal.COMMENT_MULTILINE, nodeCreationInformation: {commentContents: token.stringContents.substring(2, token.stringContents.length - 2)}}\n                }\n            } else {\n                retDirective = {symbol: {symbolType: Terminal.COMMENT_MULTILINE, nodeCreationInformation: {commentContents: token.stringContents.substring(2, token.stringContents.length - 2)}}};\n            }\n\n            // reset\n            this.functBodyHasOthers = false;\n            this.functBodyHasPreviousContent = false;\n        } else {\n            this.functBodyHasPreviousContent = true;\n            if (token.tokenType !== TokenType.SPACINGS) {\n                this.functBodyHasOthers = true;\n            }\n        }\n\n        return retDirective;\n    }\n\n\n    private functDeclStartParseIdx: number;\n    private functDeclParsing: boolean;\n    protected detectFunctionDeclarationSymbol(state: (Terminal | NonTerminal)[], token: Token | null, currentTokIndex: number, depth: number): SymbolAdditionDirective | null {\n        // simply separate by commas\n        if (token === null) {\n            return {symbol: {symbolType: Terminal.FILLER}};\n        }\n\n        let retDirective: SymbolAdditionDirective | null = null;\n        if (this.functDeclParsing) {\n            const action = this.argumentMatcher.next(token);\n            if (action !== null) {\n                // conclude\n                retDirective = {\n                    symbol: {symbolType: Terminal.FILLER},\n                    secondSymbol: {symbolType: Terminal.ARGUMENT, nodeCreationInformation: {argumentName: action.name, argumentType: action.type}},\n                    secondSymbolLen: currentTokIndex - this.functDeclStartParseIdx - 1,\n                    firstTwoSymbolsEndBufferLen: 1\n                };\n                this.functDeclStartParseIdx = currentTokIndex;\n            }\n        }\n        this.updateBracesAndTerminateStatementsState(token, currentTokIndex);\n        if (this.functDeclParsing && this.bracesMatcher.currentDepth() === 0) { // function declaration is closed\n            this.functDeclParsing = false;\n\n            // conclude, since bracket ended\n            const action = this.argumentMatcher.reset();\n            if (action !== null) {\n                // conclude\n                retDirective = {\n                    symbol: {symbolType: Terminal.FILLER},\n                    secondSymbol: {symbolType: Terminal.ARGUMENT, nodeCreationInformation: {argumentName: action.name, argumentType: action.type}},\n                    secondSymbolLen: currentTokIndex - this.functDeclStartParseIdx - 1,\n                    firstTwoSymbolsEndBufferLen: 1\n                };\n                this.functDeclStartParseIdx = currentTokIndex;\n            }\n        } else if (this.bracesMatcher.currentDepth() > 0 && this.functDeclStartParseIdx === -1) {\n            this.functDeclStartParseIdx = currentTokIndex;\n            this.functDeclParsing = true;\n        }\n\n        return retDirective;\n    }\n\n    private codeBlocksHasComments: boolean;\n    private codeBlocksSymbolToDetect: Terminal | NonTerminal;\n    private codeBlocksLastSymbolDetectionEnd: number; // inclusive\n    private codeBlocksHasContents: boolean; // to determine whether there are contents or not (filler or statements filler)\n    private codeBlocksStartOfPotentialDetection: number; // inclusive\n    private detectCodeBlocks(token: Token | null, currentTokIndex: number): SymbolAdditionDirective | null {\n        if (token === null) {\n            if (this.codeBlocksSymbolToDetect === Terminal.STATEMENTS_FILLER) {\n                const fillerType: Terminal = this.codeBlocksHasContents ? Terminal.STATEMENTS_FILLER : Terminal.FILLER;\n                return {symbol: {symbolType: fillerType}};\n            }\n            // try to conclude\n            const action = this.attemptConcludeCodeBlock(this.codeBlocksSymbolToDetect);\n            if (action.create === undefined) {\n                return {symbol: {symbolType: Terminal.STATEMENTS_FILLER}}; // have something in there which makes it a statements filler\n            } else {\n                const gap = this.codeBlocksStartOfPotentialDetection - this.codeBlocksLastSymbolDetectionEnd - 1;\n                if (gap > 0) {\n                    const fillerType: Terminal = this.codeBlocksHasContents ? Terminal.STATEMENTS_FILLER : Terminal.FILLER;\n                    return {\n                        symbol: {symbolType: fillerType},\n                        secondSymbol: action.create,\n                        secondSymbolLen: currentTokIndex - this.codeBlocksStartOfPotentialDetection\n                    };\n                } else {\n                    return {symbol: action.create};\n                }\n            }\n        }\n        let retValue: SymbolAdditionDirective | null = null;\n        const startStatementIdx: number = currentTokIndex - this.mostRecentStatementsEndTokIdx - 1;\n        if (startStatementIdx === 0) {\n            // needs reset of detection\n            if (this.codeBlocksSymbolToDetect !== Terminal.STATEMENTS_FILLER) {\n                this.codeBlocksSymbolToDetect = Terminal.STATEMENTS_FILLER;\n                this.codeBlocksHasContents = true; // there are contents, since there is probably an incomplete detection\n            }\n            this.codeBlocksHasComments = false;\n        }\n        // handle different cases\n        if (this.codeBlocksSymbolToDetect === Terminal.STATEMENTS_FILLER) {\n            // try to upgrade\n            if (!this.codeBlocksHasComments) { // upgrade only if no comments\n                if (token.tokenType === TokenType.SINGLELINE_COMMENTS) {\n                    const priorFillerLength: number = currentTokIndex - this.codeBlocksLastSymbolDetectionEnd - 1;\n                    const comments: string = token.stringContents.substring(2, token.stringContents.length);\n\n                    if (priorFillerLength === 0) {\n                        retValue = {symbol: {symbolType: Terminal.COMMENT_SINGLELINE, nodeCreationInformation: {commentContents: comments}}};\n                    } else {\n                        const fillerType: Terminal = this.codeBlocksHasContents ? Terminal.STATEMENTS_FILLER : Terminal.FILLER;\n                        retValue = {\n                            symbol: {symbolType: fillerType},\n                            secondSymbol: {symbolType: Terminal.COMMENT_SINGLELINE, nodeCreationInformation: {commentContents: comments}}\n                        };\n                    }\n\n                    // reset\n                    this.codeBlocksHasComments = true;\n                    this.codeBlocksLastSymbolDetectionEnd = currentTokIndex;\n                    this.codeBlocksHasContents = false;\n                } else if (token.tokenType === TokenType.MULTILINE_COMMENTS_OR_STRINGS && token.stringContents.startsWith(\"/*\") && token.stringContents.endsWith(\"*/\")) {\n                    const priorFillerLength: number = currentTokIndex - this.codeBlocksLastSymbolDetectionEnd - 1;\n                    const comments: string = token.stringContents.substring(2, token.stringContents.length - 2);\n\n                    this.codeBlocksHasComments = true;\n                    this.codeBlocksLastSymbolDetectionEnd = currentTokIndex;\n                    if (priorFillerLength === 0) {\n                        retValue = {symbol: {symbolType: Terminal.COMMENT_MULTILINE, nodeCreationInformation: {commentContents: comments}}};\n                    } else {\n                        const fillerType: Terminal = this.codeBlocksHasContents ? Terminal.STATEMENTS_FILLER : Terminal.FILLER;\n                        retValue = {\n                            symbol: {symbolType: fillerType},\n                            secondSymbol: {symbolType: Terminal.COMMENT_MULTILINE, nodeCreationInformation: {commentContents: comments}}\n                        };\n                    }\n\n                    // reset\n                    this.codeBlocksHasComments = true;\n                    this.codeBlocksLastSymbolDetectionEnd = currentTokIndex;\n                    this.codeBlocksHasContents = false;\n                } else {\n                    // await the first non-spacing token.\n                    // therefore, the first token must be a non-spacing. afterwards, there is no restriction\n                    if (!this.continuousSpacingsAfterTerminateStatements || token.tokenType !== TokenType.SPACINGS) {\n                        if (this.continuousSpacingsAfterTerminateStatements) {\n                            this.codeBlocksStartOfPotentialDetection = currentTokIndex;\n                        }\n                        retValue = this.detectSymbolsAsCodeBlocks(token, currentTokIndex, currentTokIndex - this.codeBlocksStartOfPotentialDetection);\n                    }\n                }\n            } else {\n                if (token.tokenType === TokenType.SINGLELINE_COMMENTS) {\n                    const priorFillerLength: number = currentTokIndex - this.codeBlocksLastSymbolDetectionEnd - 1;\n                    const comments: string = token.stringContents.substring(2, token.stringContents.length);\n\n                    if (priorFillerLength === 0) {\n                        retValue = {symbol: {symbolType: Terminal.COMMENT_SINGLELINE, nodeCreationInformation: {commentContents: comments}}};\n                    } else {\n                        const fillerType: Terminal = this.codeBlocksHasContents ? Terminal.STATEMENTS_FILLER : Terminal.FILLER;\n                        retValue = {\n                            symbol: {symbolType: fillerType},\n                            secondSymbol: {symbolType: Terminal.COMMENT_SINGLELINE, nodeCreationInformation: {commentContents: comments}}\n                        };\n                    }\n\n                    // reset\n                    this.codeBlocksLastSymbolDetectionEnd = currentTokIndex;\n                    this.codeBlocksHasContents = false;\n                } else if (token.tokenType === TokenType.MULTILINE_COMMENTS_OR_STRINGS && token.stringContents.startsWith(\"/*\") && token.stringContents.endsWith(\"*/\")) {\n                    const priorFillerLength: number = currentTokIndex - this.codeBlocksLastSymbolDetectionEnd - 1;\n                    const comments: string = token.stringContents.substring(2, token.stringContents.length - 2);\n\n                    this.codeBlocksHasComments = true;\n                    this.codeBlocksLastSymbolDetectionEnd = currentTokIndex;\n                    if (priorFillerLength === 0) {\n                        retValue = {symbol: {symbolType: Terminal.COMMENT_MULTILINE, nodeCreationInformation: {commentContents: comments}}};\n                    } else {\n                        const fillerType: Terminal = this.codeBlocksHasContents ? Terminal.STATEMENTS_FILLER : Terminal.FILLER;\n                        retValue = {\n                            symbol: {symbolType: fillerType},\n                            secondSymbol: {symbolType: Terminal.COMMENT_MULTILINE, nodeCreationInformation: {commentContents: comments}}\n                        };\n                    }\n\n                    // reset\n                    this.codeBlocksLastSymbolDetectionEnd = currentTokIndex;\n                    this.codeBlocksHasContents = false;\n                } else if (token.tokenType !== TokenType.SPACINGS){\n                    // we've detected something else, so we flag it\n                    this.codeBlocksHasContents = true;\n                }\n            }\n        } else {\n            retValue = this.detectSymbolsAsCodeBlocks(token, currentTokIndex, currentTokIndex - this.codeBlocksStartOfPotentialDetection);\n        }\n        \n\n        this.updateBracesAndTerminateStatementsState(token, currentTokIndex);\n        return retValue;\n    }\n\n    private cbSymbSpacesTextsOnly: boolean;\n    private cbSymbAttemptedDetect: boolean;\n    private cbSymbStringStream: string;\n    private cbSymbTokenStream: Token[];\n\n    private cbSymbClassOpeningBrace: number;\n    private cbSymbClassClosingBrace: number;\n    private cbSymbClassDefnText: string | null;\n\n    private cbSymbFuncOpeningBracket: number;\n    private cbSymbFuncClosingBracket: number;\n    private cbSymbFuncOpeningBrace: number;\n    private cbSymbFuncClosingBrace: number;\n    private cbSymbFuncDefnText: string | null;\n    private cbSymbFuncPreviousImmediatelyColon: boolean;\n    private cbSymbFuncRetTypeBracesMatcher: BracesMatcher;\n    private detectSymbolsAsCodeBlocks(token: Token, currentTokIndex: number, startStatementIdx: number): SymbolAdditionDirective | null {\n        if (startStatementIdx === 0) {\n            // reset\n            this.cbSymbSpacesTextsOnly = true;\n            this.cbSymbAttemptedDetect = false;\n            this.cbSymbStringStream = \"\";\n            this.cbSymbTokenStream = [];\n\n            this.cbSymbClassOpeningBrace = -1;\n            this.cbSymbClassClosingBrace = -1;\n            this.cbSymbClassDefnText = null;\n\n            this.cbSymbFuncOpeningBracket = -1;\n            this.cbSymbFuncClosingBracket = -1;\n            this.cbSymbFuncOpeningBrace = -1;\n            this.cbSymbFuncClosingBrace = -1;\n            this.cbSymbFuncDefnText = null;\n            this.cbSymbFuncPreviousImmediatelyColon = false;\n            this.cbSymbFuncRetTypeBracesMatcher.reset();\n        }\n        this.cbSymbStringStream += token.stringContents; // add no matter what\n        if (token.tokenType !== TokenType.SPACINGS) {\n            this.cbSymbTokenStream.push(token);\n        }\n\n        let action: {create?: SymbolInfo, invalidate: boolean} | null = null;\n        if (this.parseType === NonTerminal.TOP_LEVEL) {\n            if (this.codeBlocksSymbolToDetect === Terminal.STATEMENTS_FILLER) {\n                // try to upgrade the detection\n                if (!this.cbSymbAttemptedDetect) { // upgrade only if its fresh\n                    if (startStatementIdx === 0 && token.stringContents === \"import\") {\n                        this.codeBlocksSymbolToDetect = Terminal.REFERENCES;\n                        this.cbSymbAttemptedDetect = true;\n                    } else if (this.cbSymbTokenStream[0].stringContents === \"export\" && token.stringContents === \"from\") { // try export from\n                        this.codeBlocksSymbolToDetect = Terminal.REFERENCES;\n                        this.cbSymbAttemptedDetect = true;\n                    } else if (this.cbSymbSpacesTextsOnly && (token.stringContents === \"class\" || token.stringContents === \"interface\")) {\n                        this.codeBlocksSymbolToDetect = NonTerminal.CLASSES;\n                        this.cbSymbAttemptedDetect = true;\n                    } else if (this.cbSymbSpacesTextsOnly && token.stringContents === \"function\") {\n                        this.codeBlocksSymbolToDetect = NonTerminal.FUNCTIONS;\n                        this.cbSymbAttemptedDetect = true;\n                    }\n                }\n            } else if (this.codeBlocksSymbolToDetect === Terminal.REFERENCES) {\n                if (this.checkCodeEndCondition(token)) {\n                    // reached end. check string\n                    action = this.attemptConcludeCodeBlock(this.codeBlocksSymbolToDetect);\n                }\n            } else if (this.codeBlocksSymbolToDetect === NonTerminal.CLASSES) {\n                if (this.checkCodeEndCondition(token)) {\n                    // reached end. check string\n                    action = this.attemptConcludeCodeBlock(this.codeBlocksSymbolToDetect);\n                } else {\n                    if (this.cbSymbClassOpeningBrace !== -1) {\n                        // await the closing brace\n                        if (this.cbSymbClassClosingBrace !== -1 && token.tokenType !== TokenType.SPACINGS) {\n                            // got non spacing tokens after closed. invalid. downgrade now\n                            this.codeBlocksHasContents = true; // failed class. therefore has some unwanted contents\n                            this.codeBlocksSymbolToDetect = Terminal.STATEMENTS_FILLER;\n                        } else if (token.stringContents === \"}\" && this.bracesMatcher.currentDepth() === 1) {\n                            this.cbSymbClassClosingBrace = currentTokIndex;\n                        }\n                    } else {\n                        // await the opening brace\n                        if (token.stringContents === \"{\" && this.bracesMatcher.currentDepth() === 0) {\n                            this.cbSymbClassOpeningBrace = currentTokIndex;\n\n                            // set the class definition text\n                            this.cbSymbClassDefnText = this.stripString(this.cbSymbStringStream.substring(0, this.cbSymbStringStream.length - 1));\n                        }\n                    }\n                }\n            } else if (this.codeBlocksSymbolToDetect === NonTerminal.FUNCTIONS) {\n                if (this.checkCodeEndCondition(token)) {\n                    action = this.attemptConcludeCodeBlock(this.codeBlocksSymbolToDetect);\n                } else {\n                    // detect the opening and closing bracket pairs, and then the opening and closing braces\n                    if (this.cbSymbFuncOpeningBracket === -1) {\n                        if (token.stringContents === \"(\" && this.bracesMatcher.currentDepth() === 0) {\n                            this.cbSymbFuncOpeningBracket = currentTokIndex;\n                        }\n                    } else if (this.cbSymbFuncClosingBracket === -1) {\n                        if (token.stringContents === \")\" && this.bracesMatcher.currentDepth() === 1) {\n                            this.cbSymbFuncClosingBracket = currentTokIndex;\n                        }\n                    } else if (this.cbSymbFuncOpeningBrace === -1) {\n                        // try to detect the opening brace\n                        if (this.cbSymbFuncRetTypeBracesMatcher.currentDepth() === 0 && !this.cbSymbFuncPreviousImmediatelyColon && token.stringContents === \"{\") {\n                            this.cbSymbFuncDefnText = this.stripString(this.cbSymbStringStream.substring(0, this.cbSymbStringStream.length - 1));\n                            this.cbSymbFuncOpeningBrace = currentTokIndex;\n                            this.cbSymbFuncRetTypeBracesMatcher.reset();\n                        }\n\n                        if (token.tokenType == TokenType.BRACES || token.stringContents === \"<\" || token.stringContents === \">\") {\n                            try {\n                                this.cbSymbFuncRetTypeBracesMatcher.next(token.stringContents);\n                            } catch (e: any) {\n                                if (e instanceof Error) {\n                                    throw new CodeParsingError(\"Error during brace matching! \" + e.message);\n                                }\n                                throw e;\n                            }\n                        }\n                    } else if (this.cbSymbFuncClosingBrace === -1) {\n                        // try to detect the closing brace\n                        if (this.curlyBracesMatcher.currentDepth() === 1 && token.stringContents === \"}\") {\n                            this.cbSymbFuncClosingBrace = currentTokIndex;\n                        }\n                    } else if (token.tokenType !== TokenType.SPACINGS) {\n                        // got non spacing tokens after closed. invalid. downgrade now\n                        this.codeBlocksHasContents = true; // failed function. therefore has some unwanted contents\n                        this.codeBlocksSymbolToDetect = Terminal.STATEMENTS_FILLER;\n                    }\n\n                    if (token.stringContents === \":\") {\n                        this.cbSymbFuncPreviousImmediatelyColon = true;\n                    } else if (token.tokenType !== TokenType.SPACINGS) {\n                        this.cbSymbFuncPreviousImmediatelyColon = false;\n                    }\n                }\n            }\n        } else if (this.parseType === NonTerminal.CLASSES) {\n            if (this.codeBlocksSymbolToDetect === Terminal.STATEMENTS_FILLER) {\n                // try to upgrade the detection\n                if (!this.cbSymbAttemptedDetect) { // upgrade only if its fresh\n                    if (this.cbSymbTokenStream.length >= 2 && token.stringContents === \":\" && this.bracesMatcher.currentDepth() === 0 && this.cbSymbSpacesTextsOnly) {\n                        this.codeBlocksSymbolToDetect = Terminal.ATTRIBUTES;\n                        this.cbSymbAttemptedDetect = true;\n                        // upgrade to attributes, and use var decl matcher to match the contents\n                        this.argumentMatcher.reset();\n                        this.argumentMatcher.next(this.cbSymbTokenStream[this.cbSymbTokenStream.length - 2]);\n                        this.argumentMatcher.next(this.cbSymbTokenStream[this.cbSymbTokenStream.length - 1]);\n                    } else if (this.cbSymbSpacesTextsOnly && token.stringContents === \"(\" && this.bracesMatcher.currentDepth() === 0) {\n                         // first bracket upgrade to functions\n                        this.codeBlocksSymbolToDetect = NonTerminal.FUNCTIONS;\n                        this.cbSymbAttemptedDetect = true;\n                        this.cbSymbFuncOpeningBracket = currentTokIndex;\n                    }\n                }\n            } else if (this.codeBlocksSymbolToDetect === Terminal.ATTRIBUTES) {\n                if (this.checkCodeEndCondition(token)) {\n                    // reached end. check string\n                    action = this.attemptConcludeCodeBlock(this.codeBlocksSymbolToDetect);\n                } else {\n                    this.argumentMatcher.next(token);\n                }\n            } else if (this.codeBlocksSymbolToDetect === NonTerminal.FUNCTIONS) {\n                if (this.checkCodeEndCondition(token)) {\n                    action = this.attemptConcludeCodeBlock(this.codeBlocksSymbolToDetect);\n                } else {\n                    // detect the closing bracket pairs, and then the opening and closing braces\n                    if (this.cbSymbFuncClosingBracket === -1) {\n                        if (token.stringContents === \")\" && this.bracesMatcher.currentDepth() === 1) {\n                            this.cbSymbFuncClosingBracket = currentTokIndex;\n                        }\n                    } else if (this.cbSymbFuncOpeningBrace === -1) {\n                        // try to detect the opening brace\n                        if (this.cbSymbFuncRetTypeBracesMatcher.currentDepth() === 0 && !this.cbSymbFuncPreviousImmediatelyColon && token.stringContents === \"{\") {\n                            this.cbSymbFuncDefnText = this.stripString(this.cbSymbStringStream.substring(0, this.cbSymbStringStream.length - 1));\n                            this.cbSymbFuncOpeningBrace = currentTokIndex;\n                            this.cbSymbFuncRetTypeBracesMatcher.reset();\n                        }\n\n                        if (token.tokenType == TokenType.BRACES || token.stringContents === \"<\" || token.stringContents === \">\") {\n                            try {\n                                this.cbSymbFuncRetTypeBracesMatcher.next(token.stringContents);\n                            } catch (e: any) {\n                                if (e instanceof Error) {\n                                    throw new CodeParsingError(\"Error during brace matching! \" + e.message);\n                                }\n                                throw e;\n                            }\n                        }\n                    } else if (this.cbSymbFuncClosingBrace === -1) {\n                        // try to detect the closing brace\n                        if (this.curlyBracesMatcher.currentDepth() === 1 && token.stringContents === \"}\") {\n                            this.cbSymbFuncClosingBrace = currentTokIndex;\n                        }\n                    } else if (token.tokenType !== TokenType.SPACINGS) {\n                        // got non spacing tokens after closed. invalid. downgrade now\n                        this.codeBlocksHasContents = true; // failed function. therefore has some unwanted contents\n                        this.codeBlocksSymbolToDetect = Terminal.STATEMENTS_FILLER;\n                    }\n\n                    if (token.stringContents === \":\") {\n                        this.cbSymbFuncPreviousImmediatelyColon = true;\n                    } else if (token.tokenType !== TokenType.SPACINGS) {\n                        this.cbSymbFuncPreviousImmediatelyColon = false;\n                    }\n                }\n            }\n        } else {\n            throw Error(\"Unexpected!\");\n        }\n\n        let retValue: SymbolAdditionDirective | null = null;\n        if (action !== null) {\n            if ((action.create === undefined) !== action.invalidate) {\n                throw Error(\"Unexpected!\");\n            }\n            if (action.create === undefined) {\n                // need to invalidate. failed detection, therefore has some unwanted contents\n                this.codeBlocksHasContents = true;\n            } else {\n                // check whether two are created or others\n                if (this.codeBlocksStartOfPotentialDetection - this.codeBlocksLastSymbolDetectionEnd === 1) {\n                    // ok, this means there are no gaps (since start of detection is inclusive, and detection end is inclusive)\n                    retValue = {symbol: action.create, secondSymbolLen: 1}; // exclude the current spacing token\n                } else {\n                    // there are gaps\n                    const fillerType: Terminal = this.codeBlocksHasContents ? Terminal.STATEMENTS_FILLER : Terminal.FILLER;\n                    retValue = {\n                        symbol: {symbolType: fillerType},\n                        secondSymbol: action.create,\n                        secondSymbolLen: currentTokIndex - this.codeBlocksStartOfPotentialDetection, // not including the current spacing token\n                        firstTwoSymbolsEndBufferLen: 1\n                    };\n                }\n\n                // update the end\n                this.codeBlocksLastSymbolDetectionEnd = currentTokIndex - 1;\n            }\n            this.codeBlocksSymbolToDetect = Terminal.STATEMENTS_FILLER; // downgrade to statements filler\n        }\n\n        if (!(token.tokenType === TokenType.SPACINGS || token.tokenType === TokenType.OTHERS)) {\n            this.cbSymbSpacesTextsOnly = false;\n        }\n        return retValue;\n    }\n\n    private attemptConcludeCodeBlock(symbolToDetect: Terminal | NonTerminal): {create?: SymbolInfo, invalidate: boolean} {\n        if (this.parseType === NonTerminal.TOP_LEVEL) {\n            if (symbolToDetect === Terminal.REFERENCES) {\n                if (this.cbSymbTokenStream.length >= 3 && (this.cbSymbTokenStream[0].stringContents === \"import\" || this.cbSymbTokenStream[0].stringContents === \"export\")\n                    && this.cbSymbTokenStream[this.cbSymbTokenStream.length - 2].stringContents === \"from\"\n                    && this.cbSymbTokenStream[this.cbSymbTokenStream.length - 1].tokenType === TokenType.STRINGS\n                ) {\n                    // we conclude only if the format is largely correct\n                    const referenceText: string = this.stripString(this.cbSymbStringStream.substring(0, this.cbSymbStringStream.length - 1));\n                    let referenceLoc: string = this.cbSymbTokenStream[this.cbSymbTokenStream.length - 1].stringContents;\n                    referenceLoc = referenceLoc.substring(1, referenceLoc.length - 1);\n                    // try to resolve the reference relative path\n                    let refRelativePath: string | null = null;\n                    if (referenceLoc.startsWith(\"./\")) {\n                        referenceLoc = referenceLoc.substring(2, referenceLoc.length);\n                        if (referenceLoc.length > 0) {\n                            refRelativePath = \"local-file://\" + referenceLoc;\n                        }\n                    } else if (referenceLoc.startsWith(\"../\")) {\n                        referenceLoc = referenceLoc.substring(3, referenceLoc.length);\n                        if (referenceLoc.length > 0) {\n                            refRelativePath = \"local-file://../\" + referenceLoc;\n                        }\n                    } else {\n                        if (referenceLoc.length > 0) {\n                            refRelativePath = \"environment://\" + referenceLoc;\n                        }\n                    }\n\n                    // ok, set the return type\n                    const creationInfo = {referenceText: referenceText, refRelativePath: refRelativePath};\n                    const symbol: SymbolInfo = {symbolType: Terminal.REFERENCES, nodeCreationInformation: creationInfo};\n                    return {create: symbol, invalidate: false};\n                } else {\n                    return {invalidate: true};\n                }\n            } else if (symbolToDetect === NonTerminal.CLASSES) {\n                if (this.cbSymbClassOpeningBrace !== -1 && this.cbSymbClassClosingBrace !== -1 && this.cbSymbClassDefnText !== null) {\n                    // ok, get the information\n                    const tokRange: TokenRange = {startTok: this.cbSymbClassOpeningBrace + 1, endTok: this.cbSymbClassClosingBrace};\n                    const range: Range = this.getRange(this.getTokenChRange(tokRange.startTok).start, this.getTokenChRange(tokRange.endTok).start);\n                    const creationInfo: {classDefinitionText: string, classType: null, classInnerRange: Range} = {\n                        classDefinitionText: this.cbSymbClassDefnText,\n                        classType: null,\n                        classInnerRange: range\n                    };\n                    const symbol: SymbolInfo = {symbolType: NonTerminal.CLASSES, nodeCreationInformation: creationInfo, parseRange: tokRange};\n                    return {create: symbol, invalidate: false};\n                } else {\n                    return {invalidate: true};\n                }\n            } else if (symbolToDetect === NonTerminal.FUNCTIONS) {\n                if (this.cbSymbFuncOpeningBracket !== -1 && this.cbSymbFuncClosingBracket !== -1 && this.cbSymbFuncOpeningBrace !== -1 &&\n                    this.cbSymbFuncClosingBrace !== -1 && this.cbSymbFuncDefnText !== null && (this.cbSymbFuncClosingBrace - this.cbSymbFuncOpeningBrace > 1)\n                ) {\n                    const range: Range = this.getRange(this.getTokenChRange(this.cbSymbFuncOpeningBrace + 1).start, this.getTokenChRange(this.cbSymbFuncClosingBrace).start);\n                    const creationInfo: {functionDefinitionText: string, funcInnerRange: Range} = {\n                        functionDefinitionText: this.cbSymbFuncDefnText,\n                        funcInnerRange: range\n                    };\n                    const symbol: SymbolInfo = {symbolType: NonTerminal.FUNCTIONS, nodeCreationInformation: creationInfo};\n                    return {create: symbol, invalidate: false};\n                } else {\n                    return {invalidate: true};\n                }\n            } else {\n                throw Error(\"Unexpected!\");\n            }\n        } else if (this.parseType === NonTerminal.CLASSES) {\n            if (symbolToDetect === Terminal.ATTRIBUTES) {\n                const action = this.argumentMatcher.reset();\n                if (action !== null && action.name.length > 0 && action.type !== null) {\n                    const creationInfo: {attributeName: string, attributeType: string} = {\n                        attributeName: action.name,\n                        attributeType: action.type\n                    };\n                    const symbol: SymbolInfo = { symbolType: Terminal.ATTRIBUTES, nodeCreationInformation: creationInfo };\n                    return {create: symbol, invalidate: false};\n                } else {\n                    return {invalidate: true};\n                }\n            } else if (symbolToDetect === NonTerminal.FUNCTIONS) {\n                if (this.cbSymbFuncOpeningBracket !== -1 && this.cbSymbFuncClosingBracket !== -1 && this.cbSymbFuncOpeningBrace !== -1 &&\n                    this.cbSymbFuncClosingBrace !== -1 && this.cbSymbFuncDefnText !== null && (this.cbSymbFuncClosingBrace - this.cbSymbFuncOpeningBrace > 1)\n                ) {\n                    const range: Range = this.getRange(this.getTokenChRange(this.cbSymbFuncOpeningBrace + 1).start, this.getTokenChRange(this.cbSymbFuncClosingBrace).start);\n                    const creationInfo: {functionDefinitionText: string, funcInnerRange: Range} = {\n                        functionDefinitionText: this.cbSymbFuncDefnText,\n                        funcInnerRange: range\n                    };\n                    const symbol: SymbolInfo = {symbolType: NonTerminal.FUNCTIONS, nodeCreationInformation: creationInfo};\n                    return {create: symbol, invalidate: false};\n                } else {\n                    return {invalidate: true};\n                }\n            } else {\n                throw Error(\"Unexpected!\");\n            }\n        } else {\n            throw Error(\"Unexpected!\");\n        }\n    }\n\n    private updateBracesAndTerminateStatementsState(token: Token, currentTokIndex: number) {\n        if (token.tokenType === TokenType.SPACINGS) {\n            if (this.checkCodeEndCondition(token)) {\n                if (token.stringContents === \";\" && this.bracesMatcher.currentDepth() > 0) {\n                    // ok, there is probably syntax error in the code\n                    // however, we allow the ; to \"hard reset\" the braces\n                    this.bracesMatcher.reset();\n                }\n                // we have new line or statement end. reset indentation\n                this.mostRecentStatementsEndTokIdx = currentTokIndex;\n                this.continuousSpacingsAfterTerminateStatements = true;\n            }\n        } else if (token.tokenType === TokenType.BRACES) {\n            try {\n                this.bracesMatcher.next(token.stringContents);\n            } catch (e: any) {\n                if (e instanceof Error) {\n                    throw new CodeParsingError(\"Error during brace matching! \" + e.message);\n                }\n                throw e;\n            }\n            if (token.stringContents === \"{\" || token.stringContents === \"}\") {\n                try {\n                    this.curlyBracesMatcher.next(token.stringContents);\n                } catch (e: any) {\n                    if (e instanceof Error) {\n                        throw new CodeParsingError(\"Error during curly brace matching! \" + e.message);\n                    }\n                    throw e;\n                }\n            }\n            this.continuousSpacingsAfterTerminateStatements = false;\n        } else {\n            this.continuousSpacingsAfterTerminateStatements = false;\n        }\n    }\n\n    private checkCodeEndCondition(token: Token): boolean {\n        return (token.stringContents === \"\\n\" && this.bracesMatcher.currentDepth() === 0) ||\n                (token.stringContents === \";\" && this.curlyBracesMatcher.currentDepth() === 0);\n    }\n\n    private stripString(str: string): string {\n        return str.replace(/\\r\\n|\\r|\\n|\\t/g, \" \").trim();\n    }\n}\n","import { splitIntoLines } from \"../utils\";\n\nimport { TokenVisualizer } from \"./TokenVisualizer\";\nimport { TreeTokenVisualizer } from \"./TreeTokenVisualizer\";\n\nimport { Token } from \"../parsing/ParsingTypes\";\nimport { PythonTokenizer } from \"../impl/python/PythonTokenizer\";\nimport { TypeScriptTokenizer } from \"../impl/typescript/TypeScriptTokenizer\";\n\nimport { PythonParser } from \"../impl/python/PythonParser\";\nimport { AbstractSyntaxTree } from \"../parsing/AbstractSyntaxTree\";\nimport * as treeTokenizer from \"./ASTFlatteningUtils\";\nimport { TypeScriptParser } from \"../impl/typescript/TypeScriptParser\";\n\ncustomElements.define(\"token-visualizer\", TokenVisualizer);\ncustomElements.define(\"tree-token-visualizer\", TreeTokenVisualizer);\n\nexport function tokenizePython(x: string): Token[] {\n    const tokenizer = new PythonTokenizer();\n    for (let i = 0; i < x.length; i++) {\n        tokenizer.next(x.charAt(i));\n    }\n    tokenizer.next(null);\n    return tokenizer.getTokens();\n}\n\nexport function tokenizeTypeScript(x: string): Token[] {\n    const tokenizer = new TypeScriptTokenizer();\n    for (let i = 0; i < x.length; i++) {\n        tokenizer.next(x.charAt(i));\n    }\n    tokenizer.next(null);\n    return tokenizer.getTokens();\n}\n\nexport function parsePython(x: string): AbstractSyntaxTree {\n    const lines: string[] = splitIntoLines(x);\n    const parser = new PythonParser();\n    return parser.parse(lines);\n}\n\nexport function parseTypeScript(x: string): AbstractSyntaxTree {\n    const lines: string[] = splitIntoLines(x);\n    const parser = new TypeScriptParser();\n    return parser.parse(lines);\n}\n\nexport { treeTokenizer };"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","TokenType","NonTerminal","Terminal","splitIntoLines","codeString","split","rangeToIndexes","range","start","line","start_line","character","start_character","end","end_line","end_character","rangeToStartIndex","rangeToEndIndex","indexesToRange","getMaxRange","codeLines","length","compare","index1","index2","mergeRanges","ranges","Error","i","start2","end2","contains","biggerRange","insideRange","containsIndex","index","isTerminal","symbol","values","includes","TOKEN_COLORS","MULTILINE_COMMENTS_OR_STRINGS","SINGLELINE_COMMENTS","STRINGS","SPACINGS","BRACES","COMMAS","OTHERS","CONTINUATION","TokenVisualizer","HTMLElement","constructor","initialTokens","super","tokens","this","attachShadow","mode","container","document","createElement","style","fontFamily","whiteSpace","padding","border","borderRadius","shadowRoot","appendChild","render","update","toks","innerHTML","count","forEach","token","tokenType","bgColor","parts","stringContents","part","span","textContent","backgroundColor","margin","display","SyntaxNode","extra_data","parent","children","innerRangeOverride","siblingRank","getRange","overrideInnerRange","getInnerRange","hasChildren","map","child","getPrefixRange","innerRange","getSuffixRange","setParent","node","getParent","addChild","push","getSiblingRank","listChildren","slice","assertRangeValid","getDepth","Argument","argumentName","argumentType","Attributes","attributeName","attributeType","Classes","classType","classDefinitionText","Comments","isMultiLine","commentContents","FunctionDeclaration","functionName","functionReturnType","hasArguments","some","FunctionGroups","hasComment","Functions","functionDefinitionText","funcBodyNonEmpty","hasFunctionBody","flagHaveFunctionBody","References","referenceText","refRelativePath","TopLevel","CodeParserImplError","message","name","TreeTokenType","TokenAction","ASTGenericTokenizer","tokensToString","result","tok","tree","tokenString","subtreeRestrictionPath","nodeToReplace","replacementString","nodeToReplaceTokenIdx","fillTokens","tokenize","getMaxRangeAsIndices","pretokenize","recursivelyTokenize","getRoot","posttokenize","tokenizeSubtree","includeParents","disableSubtreeParsing","tempList","includeIndentation","tokenizeReplaceNode","tokenizeTargetNode","tokList","foundTokenIdx","needsFillTokens","getTexts","prefixRange","suffixRange","tokenText","getSourceTextFromRange","tokenPrefixText","tokenSuffixText","text","depth","previousNode","resolveRestrictionNode","repStr","prefixTokens","suffixTokens","action","convertIntoTokens","undefined","RESOLVE","prevChild","subRestrictionNode","additionalToken","handleFirstSuffixTokenIfNecessary","lstWithRange","handleLastSuffixTokenWithRangeIfNecessary","getCodeString","getCodeStringFromIndices","getGlobalStartIndex","getGlobalEndIndex","firstSuffixToken","lastSuffixTokenWithRange","ARGUMENT","ATTRIBUTE","CLASS","COMMENTS","FUNCTION","FUNCTION_DEFINITION","FUNCTION_GROUP","REFERENCES","TOP_LEVEL","TreeTokenVisualizer","hoverDiv","getHoverText","originalNode","counts","prevNodes","position","addEventListener","event","hoverText","showHoverDiv","currentTarget","hideHoverDiv","target","lineElement","boxShadow","textAlign","zIndex","width","height","transition","rect","getBoundingClientRect","shadowRect","host","topPosition","bottom","top","leftPosition","left","remove","AbstractTokenizer","stringBuffer","charIdx","tokStartIdx","ended","reset","onReset","next","ch","matchEndCharacter","characterRange","matchResult","matchNext","type","singleChType","numSplitCharacters","substring","getTokens","currentBufferSingleCharacter","currentBufferLength","StringOrMultilineStatus","Status","CodeBlockType","TokenizationMode","PythonTokenizer","insideStringStatus","NONE","insideSingleLineComments","previousIsEscape","contiguousQuotesCount","SINGLE_QUOTES","handleSingleQuoteSituation","DOUBLE_QUOTES","handleDoubleQuoteSituation","TRIPLE_SINGLE_QUOTES","handleTripleSingleQuoteSituation","TRIPLE_DOUBLE_QUOTES","handleTripleDoubleQuoteSituation","situation","handleOtherSituation","isPlainCharacter","StringExpressionMatcher","expressions","validateExpressions","potentialMatches","keys","matched","expr","entries","progresses","splice","j","strA","strB","endsWith","getLength","getMaxExpressionLength","maxLength","TypeScriptTokenizer","stringMatcher","COMMENT_START","MULTILINE_COMMENT_START","MULTILINE_COMMENT_END","matchedExpression","MULTILINE_BACKTICKS","handleMultilineBackticksSituation","MULTILINE_COMMENTS","handleMultilineCommentsSituation","EQUALS","handleEqualsSituation","needsResetSplitChars","newChType","CodeParsingError","BracesMatcher","braces","openingToClosing","Map","closingToOpening","stack","tempIntersectionCheck","brace","opening","closing","set","has","lastOpening","expectedClosing","pop","currentDepth","AbstractSyntaxTree","sourceLines","getSourceText","lines","Math","min","join","getSmallestNodeContains","outer","getNodeContainsIndex","terminationCondition","AbstractParser","positionMap","numChars","sourceTokens","parse","tokenizer","preparseGetTokenizer","lineIndex","charAt","preparse","maxRange","rootNode","ast","parseNonTerminal","startTok","endTok","getTokenChRange","tokIdx","getIndex","chIndex","chStartIdx","chEndIdx","getSubstring","str","getCharacterFromIndex","lineContent","getCharacter","getCodeLength","nonTerminal","tokRange","currentTokIndex","parsedEndTokIndex","resetDetectionState","state","ntParseRange","symbolRange","nodeCreationInformation","tokenBuffer","updateTokenStreamState","validateParsingStateTopLevel","CLASSES","validateParsingStateClasses","FUNCTIONS","validateParsingStateFunctions","FUNCTION_BODY","validateParsingStateFunctionBody","FUNCTION_DECLARATION","validateParsingStateFunctionDeclaration","childNodes","resolveIntoNode","results","getFirstLast","first","last","checkCommentFunctionPair","isCommentBeforeFunction","checkFirstCommentInFunction","danglingMultilineComment","isFirst","FILLER","ani","STATEMENTS_FILLER","rangeUnion","funcGp","subnode","isConclusion","stateHistory","detectionResult","detectTopLevelSymbol","detectClassesSymbol","detectFunctionsSymbol","detectFunctionBodySymbol","detectFunctionDeclarationSymbol","symbolType","secondSymbol","secondSymbolLen","firstTwoSymbolsEndBufferLen","parseRange","assertParseRangeCorrectness","firstSymbolStart","firstSecondSymbolSep","secondSymbolEnd","allEnd","detectedType","detectedRange","createArgumentNode","ATTRIBUTES","createAttributesNode","COMMENT_MULTILINE","createCommentsNode","COMMENT_SINGLELINE","createReferencesNode","createClassesNode","createFunctionsNode","createFunctionDeclarationNode","elem","s","PythonParser","getDetectedIndentation","pythonCodeIndents","pythonIsTabs","parseType","continuousIndentAfterNewline","mostRecentLineTokIndex","lastLineForEndCodeBlockIndex","indentationCount","parsingBlockInitiated","prevTokenEndsWithBackslash","detectionType","SINGLE_LINE","detectionSymbol","bracesMatcher","encounteredComments","singleLineImmediatelyAfterComments","stringStream","tokenStream","prevMultiline","stopAcceptingStringStream","classOrFuncBodyParseStart","globalDetectionStartIndex","functDetectingBody","functColonIndex","functRightAfterDef","functName","functRightAfterArrow","functType","functBodyHasOthers","functBodyHasPreviousContent","functBodyImmediatelyHasMLComments","functDeclStrBuffer","functDeclStartParseIdx","functDeclParsing","spaceIndentCounts","tabIndentCount","trim","match","indent","hasSpaces","hasTabs","spaceCount","possibleFactors","indentStep","factor","filter","repeat","classInnerRange","funcInnerRange","startTokIndex","parsingNonTerminal","detectCodeBlocks","indexOf","e","retDirective","updateCodeBlocksBracesAndSpacingsState","argument","trimReplaceString","idx","concludeCodeBlock","indentationExpected","hasConclusion","updateCodeBlocksContentsParseState","needsReset","MULTI_LINE","lastIndexOf","reachedGlobalEndIndex","referenceRelativePath","importContents","replace","lcPath","trimmed","functionDefnText","classDefnText","ASTFaithfulTokenizer","excludeInnerRangeIfPossible","tokenizationMode","prevEndIndex","diff","TERMINATE","TOP_LEVEL_ONLY","convertTopLevel","FUNCTIONS_AND_CLASSES","convertFunctionsAndClasses","FUNCTIONS_AND_CLASSES_AND_ARGUMENTS","convertFunctionsAndClassesAndArguments","EVERYTHING","convertEverything","comparison","fillRange","lastSuffixToken","getPrefixTokens","retTokens","PythonSimplificationTokenizer","indentation","stringEnder","bodyContents","func","comment","funcTexts","commentTexts","TypeScriptSimplificationTokenizer","flattenFaithfully","flattenPython","flattenTypeScript","typeBraces","assignmentBraces","State","SpecialTokens","TypeScriptVarDeclMatcher","typeBracesMatcher","assignmentBracesMatcher","READING_NAME","nameBuffer","typeBuffer","assignmentBuffer","handleReadingName","READING_TYPE","handleReadingType","READING_ASSIGNMENT","handleReadingAssignment","retValue","assignment","x","isOpeningBraceType","isClosingBraceType","isOpeningBraceAssignment","isClosingBraceAssignment","TypeScriptParser","curlyBracesMatcher","argumentMatcher","mostRecentStatementsEndTokIdx","continuousSpacingsAfterTerminateStatements","functOpeningBracket","functClosingBracket","functOpeningBrace","functClosingBrace","functRetTypeBracesMatcher","functPreviousImmediatelyColon","functPreviousImmediatelyClosingBracket","codeBlocksHasComments","codeBlocksSymbolToDetect","codeBlocksLastSymbolDetectionEnd","codeBlocksHasContents","codeBlocksStartOfPotentialDetection","cbSymbSpacesTextsOnly","cbSymbAttemptedDetect","cbSymbStringStream","cbSymbTokenStream","cbSymbClassOpeningBrace","cbSymbClassClosingBrace","cbSymbClassDefnText","cbSymbFuncOpeningBracket","cbSymbFuncClosingBracket","cbSymbFuncOpeningBrace","cbSymbFuncClosingBrace","cbSymbFuncDefnText","cbSymbFuncPreviousImmediatelyColon","cbSymbFuncRetTypeBracesMatcher","stripString","updateBracesAndTerminateStatementsState","startsWith","attemptConcludeCodeBlock","create","priorFillerLength","comments","detectSymbolsAsCodeBlocks","startStatementIdx","checkCodeEndCondition","invalidate","symbolToDetect","referenceLoc","creationInfo","tokenizePython","tokenizeTypeScript","parsePython","parseTypeScript","customElements"],"sourceRoot":""}